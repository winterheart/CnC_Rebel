/*
**	Command & Conquer Renegade(tm)
**	Copyright 2025 Electronic Arts Inc.
**
**	This program is free software: you can redistribute it and/or modify
**	it under the terms of the GNU General Public License as published by
**	the Free Software Foundation, either version 3 of the License, or
**	(at your option) any later version.
**
**	This program is distributed in the hope that it will be useful,
**	but WITHOUT ANY WARRANTY; without even the implied warranty of
**	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
**	GNU General Public License for more details.
**
**	You should have received a copy of the GNU General Public License
**	along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*************************************************************************** 
 ***    C O N F I D E N T I A L  ---  W E S T W O O D  S T U D I O S     *** 
 *************************************************************************** 
 *                                                                         * 
 *                 Project Name : G                                        * 
 *                                                                         * 
 *                     $Archive:: /VSS_Sync/ww3d2/part_buf.cpp            $* 
 *                                                                         * 
 *                      $Author:: Vss_sync                                $* 
 *                                                                         * 
 *                     $Modtime:: 10/26/01 2:56p                          $* 
 *                                                                         * 
 *                    $Revision:: 21                                      $* 
 *                                                                         * 
 *-------------------------------------------------------------------------* 
 * Functions:                                                              * 
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
#include "part_buf.h"
#include "part_emt.h"
#include "ww3d.h"
#include "rinfo.h"
#include "scene.h"
#include "camera.h"
#include "predlod.h"
#include "pot.h"
#include "bound.h"
#include "simplevec.h"
#include "sphere.h"
#include "wwprofile.h"
#include <limits.h>
#include "vp.h"
#include "texture.h"
#include "dx8wrapper.h"
#include "vector3.h"

// A random permutation of the numbers 0 to 15 - used for LOD particle decimation.
// It was generated by the amazingly high-tech method of pulling numbers out of a hat.
const unsigned int ParticleBufferClass::PermutationArray[16] = {
	11, 3, 7, 14, 0, 13, 1, 2, 5, 12, 15, 6, 9, 8, 4, 10
};

// Maximum size of randomizer tables
const static unsigned int MAX_RANDOM_ENTRIES = 32;	// MUST be power of two!

// Total Active Particle Buffer Count
unsigned int ParticleBufferClass::TotalActiveCount = 0;

// Static array of screen-size clamps for the 17 possible LOD levels a particle buffer can have.
// We can change these from being global to being per-buffer later if we wish. Default is
// NO_MAX_SCREEN_SIZE.
float ParticleBufferClass::LODMaxScreenSizes[17] = {
	NO_MAX_SCREEN_SIZE, NO_MAX_SCREEN_SIZE, NO_MAX_SCREEN_SIZE, NO_MAX_SCREEN_SIZE,
	NO_MAX_SCREEN_SIZE, NO_MAX_SCREEN_SIZE, NO_MAX_SCREEN_SIZE, NO_MAX_SCREEN_SIZE,
	NO_MAX_SCREEN_SIZE, NO_MAX_SCREEN_SIZE, NO_MAX_SCREEN_SIZE, NO_MAX_SCREEN_SIZE,
	NO_MAX_SCREEN_SIZE, NO_MAX_SCREEN_SIZE, NO_MAX_SCREEN_SIZE, NO_MAX_SCREEN_SIZE,
	NO_MAX_SCREEN_SIZE
};

static Random4Class rand_gen;
const float oo_intmax = 1.0f / (float)INT_MAX;

// Default Line Emitter Properties
static const W3dEmitterLinePropertiesStruct _DefaultLineEmitterProps=
{ 0,0,0.0f,1.5f,1.0f,0.0f,0.0f,0,0,0,0,0,0,0,0,0 };

ParticleBufferClass::ParticleBufferClass
(
	ParticleEmitterClass *emitter, 
	unsigned int buffer_size,
	ParticlePropertyStruct<Vector3> &color, 
	ParticlePropertyStruct<float> &opacity,
	ParticlePropertyStruct<float> &size, 
	ParticlePropertyStruct<float> &rotation,
	float orient_rnd,
	ParticlePropertyStruct<float> &frame,
	ParticlePropertyStruct<float> &blurtime,
	Vector3 accel, 
	float max_age, 
	TextureClass *tex,
	ShaderClass shader, 
	bool pingpong,
	int render_mode, 
	int frame_mode,
	const W3dEmitterLinePropertiesStruct * line_props
) :
	NewParticleQueue(NULL),
	NewParticleQueueStart(0U),
	NewParticleQueueEnd(0U),
	NewParticleQueueCount(0U),
	RenderMode(render_mode),
	FrameMode(frame_mode),
	MaxAge(1000.0f * max_age),
	LastUpdateTime(WW3D::Get_Sync_Time()),
	IsEmitterDead(false),
	MaxSize(0.0f),
	MaxNum(buffer_size),
	Start(0U),
	End(0U),
	NewEnd(0U),
	NonNewNum(0),
	NewNum(0),
	BoundingBox(Vector3(0,0,0),Vector3(0,0,0)),
	BoundingBoxDirty(true),
	NumColorKeyFrames(0),
	ColorKeyFrameTimes(NULL),
	ColorKeyFrameValues(NULL),
	ColorKeyFrameDeltas(NULL),
	NumAlphaKeyFrames(0),
	AlphaKeyFrameTimes(NULL),
	AlphaKeyFrameValues(NULL),
	AlphaKeyFrameDeltas(NULL),
	NumSizeKeyFrames(0),
	SizeKeyFrameTimes(NULL),
	SizeKeyFrameValues(NULL),
	SizeKeyFrameDeltas(NULL),
	NumRotationKeyFrames(0),
	RotationKeyFrameTimes(NULL),
	RotationKeyFrameValues(NULL),
	HalfRotationKeyFrameDeltas(NULL),
	OrientationKeyFrameValues(NULL),
	NumFrameKeyFrames(0),
	FrameKeyFrameTimes(NULL),
	FrameKeyFrameValues(NULL),
	FrameKeyFrameDeltas(NULL),
	NumBlurTimeKeyFrames(0),
	BlurTimeKeyFrameTimes(NULL),
	BlurTimeKeyFrameValues(NULL),
	BlurTimeKeyFrameDeltas(NULL),
	NumRandomColorEntriesMinus1(0),
	RandomColorEntries(NULL),
	NumRandomAlphaEntriesMinus1(0),
	RandomAlphaEntries(NULL),
	NumRandomSizeEntriesMinus1(0),
	RandomSizeEntries(NULL),
	ColorRandom(0, 0, 0),
	OpacityRandom(0),
	SizeRandom(0),
	RotationRandom(0),
	FrameRandom(0),
	InitialOrientationRandom(0),
	NumRandomRotationEntriesMinus1(0),
	RandomRotationEntries(NULL),
	NumRandomOrientationEntriesMinus1(0),
	RandomOrientationEntries(NULL),
	NumRandomFrameEntriesMinus1(0),
	RandomFrameEntries(NULL),
	NumRandomBlurTimeEntriesMinus1(0),
	RandomBlurTimeEntries(NULL),
	PointGroup(NULL),
	LineRenderer(NULL),
	LineGroup(NULL),
	Diffuse(NULL),
	TailDiffuse(NULL),
	Color(NULL),
	Alpha(NULL),
	Size(NULL),
	Orientation(NULL),
	Frame(NULL),
	UCoord(NULL),
	TailPosition(NULL),
	APT(NULL),
	PingPongPosition(pingpong),
	Velocity(NULL),
	TimeStamp(NULL),
	Emitter(emitter),
	DecimationThreshold(0U),
	ProjectedArea(0.0f),
	DefaultTailDiffuse(0,0,0,0)
{
	LodCount = 17;
	LodBias = 1.0f;

	Position[0] = NULL;
	Position[1] = NULL;

	// Create color array, keyframes and randomizer table (if needed)
	Reset_Colors(color);

	// Create alpha array, keyframes and randomizer table (if needed)
	Reset_Opacity(opacity);

	// Create size array, keyframes and randomizer table (if needed)
	Reset_Size(size);

	// Create the rotation array, keyframes, and randomizer table (if needed)
	Reset_Rotations(rotation, orient_rnd);

	// Create the frame array, keyframes, and randomizer table (if needed)
	Reset_Frames(frame);

	// Create the blur time array, keyframes, and randomizer table if needed
	Reset_Blur_Times(blurtime);

	// We do not add a ref for the emitter (see DTor for detailed explanation)
	// if (Emitter) Emitter->Add_Ref();

	// Set up new particle queue:
	NewParticleQueue = new NewParticleStruct[MaxNum];

	// These inputs don't need to be range-checked (emitter did that).
	Accel = accel;
	HasAccel = (accel.X != 0.0f) || (accel.Y != 0.0f) || (accel.Z != 0.0f);
   
	shader.Enable_Fog ("ParticleBufferClass");
	switch (RenderMode)	
	{
	case W3D_EMITTER_RENDER_MODE_TRI_PARTICLES:
		{
			// Set up worldspace point group
			PointGroup = new PointGroupClass();
			PointGroup->Set_Flag(PointGroupClass::TRANSFORM, true);
			PointGroup->Set_Texture(tex);			
			PointGroup->Set_Shader(shader);
			PointGroup->Set_Frame_Row_Column_Count_Log2(frame_mode);
			PointGroup->Set_Point_Mode(PointGroupClass::TRIS);
		}
		break;
	case W3D_EMITTER_RENDER_MODE_QUAD_PARTICLES:
		{
			// Set up worldspace point group
			PointGroup = new PointGroupClass();
			PointGroup->Set_Flag(PointGroupClass::TRANSFORM, true);
			PointGroup->Set_Texture(tex);			
			PointGroup->Set_Shader(shader);
			PointGroup->Set_Frame_Row_Column_Count_Log2(frame_mode);
			PointGroup->Set_Point_Mode(PointGroupClass::QUADS);
		}
		break;
	case W3D_EMITTER_RENDER_MODE_LINE:
		{			
			LineRenderer = new SegLineRendererClass;
			LineRenderer->Init(*line_props);
			LineRenderer->Set_Texture(tex);
			LineRenderer->Set_Shader(shader);
			LineRenderer->Set_Width(Get_Particle_Size());
			if (line_props != NULL) {				
				LineRenderer->Init(*line_props);
			} else {
				// This code should not be run, but if it does,
				// set line emitters to some reasonable value so
				// it doesn't crash
				WWASSERT(0);
				LineRenderer->Init(_DefaultLineEmitterProps);
			}
		}
		break;
	case W3D_EMITTER_RENDER_MODE_LINEGRP_TETRA:
		{
			LineGroup=new LineGroupClass();
			LineGroup->Set_Flag(LineGroupClass::TRANSFORM, true);
			LineGroup->Set_Texture(tex);
			LineGroup->Set_Shader(shader);
			LineGroup->Set_Line_Mode(LineGroupClass::TETRAHEDRON);
			TailPosition = NEW_REF( ShareBufferClass<Vector3> , (MaxNum) );
			// TODO: Change TailPosition to Kinematic state and add
			// tail positions to bounding box
			Set_Force_Visible(1);
		}
		break;
	case W3D_EMITTER_RENDER_MODE_LINEGRP_PRISM:
		{
			LineGroup=new LineGroupClass();
			LineGroup->Set_Flag(LineGroupClass::TRANSFORM, true);
			LineGroup->Set_Texture(tex);
			LineGroup->Set_Shader(shader);
			LineGroup->Set_Line_Mode(LineGroupClass::PRISM);
			TailPosition = NEW_REF( ShareBufferClass<Vector3> , (MaxNum) );
			// TODO: Change TailPosition to Kinematic state and add
			// tail positions to bounding box
			Set_Force_Visible(1);
		}
		break;
	default:
		WWASSERT(0);
		break;
	}	

	// Set up circular buffer. Contents are not initialized because the
	// start/end indices currently indicate the buffer is empty.
	Position[0] = NEW_REF( ShareBufferClass<Vector3> , (MaxNum) );
	if (PingPongPosition) {
		Position[1] = NEW_REF( ShareBufferClass<Vector3> , (MaxNum) );
	}
	APT = NEW_REF( ShareBufferClass<unsigned int> , (MaxNum) );
	Velocity = new Vector3[MaxNum]; 
	TimeStamp = new unsigned int[MaxNum];

	// So that the object is ready for use after construction, we will
	// complete its initialization by initializing its cost and value arrays
	// according to a screen area of 1.
	int minlod = Calculate_Cost_Value_Arrays(1.0f, Value, Cost);

	// Ensure lod is no less than minimum allowed
	if (Get_LOD_Level() < minlod) Set_LOD_Level(minlod);

	// Update Global Count
	TotalActiveCount++;
}


ParticleBufferClass::ParticleBufferClass(const ParticleBufferClass & src) :
	RenderObjClass(src),
	NewParticleQueue(NULL),
	NewParticleQueueStart(0U),
	NewParticleQueueEnd(0U),
	NewParticleQueueCount(0U),
	RenderMode(src.RenderMode),
	FrameMode(src.FrameMode),
	MaxAge(src.MaxAge),
	LastUpdateTime(WW3D::Get_Sync_Time()),
	IsEmitterDead(false),
	MaxSize(src.MaxSize),
	MaxNum(src.MaxNum),
	Start(0U),
	End(0U),
	NewEnd(0U),
	NonNewNum(0),
	NewNum(0),
	BoundingBox(Vector3(0,0,0),Vector3(0,0,0)),
	BoundingBoxDirty(true),
	NumColorKeyFrames(src.NumColorKeyFrames),
	ColorKeyFrameTimes(NULL),
	ColorKeyFrameValues(NULL),
	ColorKeyFrameDeltas(NULL),
	NumAlphaKeyFrames(src.NumAlphaKeyFrames),
	AlphaKeyFrameTimes(NULL),
	AlphaKeyFrameValues(NULL),
	AlphaKeyFrameDeltas(NULL),
	NumSizeKeyFrames(src.NumSizeKeyFrames),
	SizeKeyFrameTimes(NULL),
	SizeKeyFrameValues(NULL),
	SizeKeyFrameDeltas(NULL),
	NumRotationKeyFrames(src.NumRotationKeyFrames),
	RotationKeyFrameTimes(NULL),
	RotationKeyFrameValues(NULL),
	HalfRotationKeyFrameDeltas(NULL),
	OrientationKeyFrameValues(NULL),
	NumFrameKeyFrames(src.NumFrameKeyFrames),
	FrameKeyFrameTimes(NULL),
	FrameKeyFrameValues(NULL),
	FrameKeyFrameDeltas(NULL),
	NumBlurTimeKeyFrames(src.NumBlurTimeKeyFrames),
	BlurTimeKeyFrameTimes(NULL),
	BlurTimeKeyFrameValues(NULL),
	BlurTimeKeyFrameDeltas(NULL),
	RandomColorEntries(NULL),
	RandomAlphaEntries(NULL),
	RandomSizeEntries(NULL),
	ColorRandom(src.ColorRandom),
	OpacityRandom(src.OpacityRandom),
	SizeRandom(src.SizeRandom),
	RotationRandom(src.RotationRandom),
	FrameRandom(src.FrameRandom),
	InitialOrientationRandom(src.InitialOrientationRandom),
	NumRandomRotationEntriesMinus1(0),
	RandomRotationEntries(NULL),
	NumRandomOrientationEntriesMinus1(0),
	RandomOrientationEntries(NULL),
	NumRandomFrameEntriesMinus1(0),
	RandomFrameEntries(NULL),
	NumRandomBlurTimeEntriesMinus1(0),
	RandomBlurTimeEntries(NULL),
	PointGroup(NULL),
	LineRenderer(NULL),
	LineGroup(NULL),
	Diffuse(NULL),
	TailDiffuse(NULL),
	Color(NULL),
	Alpha(NULL),
	Size(NULL),
	Orientation(NULL),
	Frame(NULL),
	UCoord(NULL),
	TailPosition(NULL),
	APT(NULL),
	PingPongPosition(src.PingPongPosition),
	Velocity(NULL),
	TimeStamp(NULL),
	Emitter(src.Emitter),
	DecimationThreshold(src.DecimationThreshold),
	ProjectedArea(0.0f),
	DefaultTailDiffuse(src.DefaultTailDiffuse)
{
	Position[0] = NULL;
	Position[1] = NULL;

	unsigned int i;

	LodCount = MIN(MaxNum, 17);
	LodBias = src.LodBias;

	/*
	** Create visual state arrays, copy keyframes and randomizer tables.
	*/

	NumRandomColorEntriesMinus1 = src.NumRandomColorEntriesMinus1;
	if (src.Color) {
		// Create color array
		Color = NEW_REF( ShareBufferClass<Vector3> , (MaxNum) );

		// Copy color keyframes
		ColorKeyFrameTimes = new unsigned int [NumColorKeyFrames];
		ColorKeyFrameValues = new Vector3 [NumColorKeyFrames];
		ColorKeyFrameDeltas = new Vector3 [NumColorKeyFrames];
		for (i = 0; i < NumColorKeyFrames; i++) {
			ColorKeyFrameTimes[i] = src.ColorKeyFrameTimes[i];
			ColorKeyFrameValues[i] = src.ColorKeyFrameValues[i];
			ColorKeyFrameDeltas[i] = src.ColorKeyFrameDeltas[i];
		}

		// Copy color randomizer table
		if (src.RandomColorEntries) {
			RandomColorEntries = new Vector3 [NumRandomColorEntriesMinus1 + 1];
			for (unsigned int j = 0; j <= NumRandomColorEntriesMinus1; j++) {
				RandomColorEntries[j] = src.RandomColorEntries[j];
			}
		}
	} else {
		ColorKeyFrameValues = new Vector3 [1];
		ColorKeyFrameValues[0] = src.ColorKeyFrameValues[0];
	}

	NumRandomAlphaEntriesMinus1 = src.NumRandomAlphaEntriesMinus1;
	if (src.Alpha) {
		// Create alpha array
		Alpha = NEW_REF( ShareBufferClass<float> , (MaxNum) );

		// Copy alpha keyframes
		AlphaKeyFrameTimes = new unsigned int [NumAlphaKeyFrames];
		AlphaKeyFrameValues = new float [NumAlphaKeyFrames];
		AlphaKeyFrameDeltas = new float [NumAlphaKeyFrames];
		for (i = 0; i < NumAlphaKeyFrames; i++) {
			AlphaKeyFrameTimes[i] = src.AlphaKeyFrameTimes[i];
			AlphaKeyFrameValues[i] = src.AlphaKeyFrameValues[i];
			AlphaKeyFrameDeltas[i] = src.AlphaKeyFrameDeltas[i];
		}

		// Copy alpha randomizer table
		if (src.RandomAlphaEntries) {
			RandomAlphaEntries = new float [NumRandomAlphaEntriesMinus1 + 1];
			for (unsigned int j = 0; j <= NumRandomAlphaEntriesMinus1; j++) {
				RandomAlphaEntries[j] = src.RandomAlphaEntries[j];
			}
		}
	} else {
		AlphaKeyFrameValues = new float [1];
		AlphaKeyFrameValues[0] = src.AlphaKeyFrameValues[0];
	}

	NumRandomSizeEntriesMinus1 = src.NumRandomSizeEntriesMinus1;
	if (src.Size) {
		// Create size array
		Size = NEW_REF( ShareBufferClass<float> , (MaxNum) );

		// Copy size keyframes
		SizeKeyFrameTimes = new unsigned int [NumSizeKeyFrames];
		SizeKeyFrameValues = new float [NumSizeKeyFrames];
		SizeKeyFrameDeltas = new float [NumSizeKeyFrames];
		for (i = 0; i < NumSizeKeyFrames; i++) {
			SizeKeyFrameTimes[i] = src.SizeKeyFrameTimes[i];
			SizeKeyFrameValues[i] = src.SizeKeyFrameValues[i];
			SizeKeyFrameDeltas[i] = src.SizeKeyFrameDeltas[i];
		}

		// Copy size randomizer table
		if (src.RandomSizeEntries) {
			RandomSizeEntries = new float [NumRandomSizeEntriesMinus1 + 1];
			for (unsigned int j = 0; j <= NumRandomSizeEntriesMinus1; j++) {
				RandomSizeEntries[j] = src.RandomSizeEntries[j];
			}
		}
	} else {
		SizeKeyFrameValues = new float [1];
		SizeKeyFrameValues[0] = src.SizeKeyFrameValues[0];
	}

	// Set up the rotation / orientation keyframes
	NumRandomRotationEntriesMinus1 = src.NumRandomRotationEntriesMinus1;
	NumRandomOrientationEntriesMinus1 = src.NumRandomOrientationEntriesMinus1;
	if (src.Orientation) {
		// Create orientation array
		Orientation = NEW_REF( ShareBufferClass<uint8> , (MaxNum) );

		// Copy rotation / orientation keyframes
		RotationKeyFrameTimes = new unsigned int [NumRotationKeyFrames];
		RotationKeyFrameValues = new float [NumRotationKeyFrames];
		HalfRotationKeyFrameDeltas = new float [NumRotationKeyFrames];
		OrientationKeyFrameValues = new float [NumRotationKeyFrames];
		for (i = 0; i < NumRotationKeyFrames; i++) {
			RotationKeyFrameTimes[i] = src.RotationKeyFrameTimes[i];
			RotationKeyFrameValues[i] = src.RotationKeyFrameValues[i];
			HalfRotationKeyFrameDeltas[i] = src.HalfRotationKeyFrameDeltas[i];
			OrientationKeyFrameValues[i] = src.OrientationKeyFrameValues[i];
		}

		// Copy rotation randomizer table
		if (src.RandomRotationEntries) {
			RandomRotationEntries = new float [NumRandomRotationEntriesMinus1 + 1];
			for (unsigned int j = 0; j <= NumRandomRotationEntriesMinus1; j++) {
				RandomRotationEntries[j] = src.RandomRotationEntries[j];
			}
		}

		// Copy starting orientation randomizer table
		if (src.RandomOrientationEntries) {
			RandomOrientationEntries = new float [NumRandomOrientationEntriesMinus1 + 1];
			for (unsigned int j = 0; j <= NumRandomOrientationEntriesMinus1; j++) {
				RandomOrientationEntries[j] = src.RandomOrientationEntries[j];
			}
		}

	} else {
		// Unlike other properties, if there is no Orientation array then all the arrays are NULL
		// (including the Values array) - there is an implicit starting value of 0.
	}


	// Set up the frame keyframes
	// Frame and UCoord both use Frame Key Frames for the source data
	NumRandomFrameEntriesMinus1 = src.NumRandomFrameEntriesMinus1;
	if (src.Frame || src.UCoord) {
		// Create frame array
		if (src.Frame) {
			Frame = NEW_REF( ShareBufferClass<uint8> , (MaxNum) );
		} else {
			UCoord = NEW_REF( ShareBufferClass<float>, (MaxNum) );
		}


		// Copy frame keyframes
		FrameKeyFrameTimes = new unsigned int [NumFrameKeyFrames];
		FrameKeyFrameValues = new float [NumFrameKeyFrames];
		FrameKeyFrameDeltas = new float [NumFrameKeyFrames];
		for (i = 0; i < NumFrameKeyFrames; i++) {
			FrameKeyFrameTimes[i] = src.FrameKeyFrameTimes[i];
			FrameKeyFrameValues[i] = src.FrameKeyFrameValues[i];
			FrameKeyFrameDeltas[i] = src.FrameKeyFrameDeltas[i];
		}

		// Copy frame randomizer table
		if (src.RandomFrameEntries) {
			RandomFrameEntries = new float [NumRandomFrameEntriesMinus1 + 1];
			for (unsigned int j = 0; j <= NumRandomFrameEntriesMinus1; j++) {
				RandomFrameEntries[j] = src.RandomFrameEntries[j];
			}
		}
	} else {
		FrameKeyFrameValues = new float [1];
		FrameKeyFrameValues[0] = src.FrameKeyFrameValues[0];
	}

	// Set up the blur times keyframes
	NumRandomBlurTimeEntriesMinus1 = src.NumRandomBlurTimeEntriesMinus1;
	if (NumBlurTimeKeyFrames > 0) {
		// Copy blur time keyframes
		BlurTimeKeyFrameTimes = new unsigned int [NumBlurTimeKeyFrames];
		BlurTimeKeyFrameValues = new float [NumBlurTimeKeyFrames];
		BlurTimeKeyFrameDeltas = new float [NumBlurTimeKeyFrames];
		for (i = 0; i < NumBlurTimeKeyFrames; i++) {
			BlurTimeKeyFrameTimes[i] = src.BlurTimeKeyFrameTimes[i];
			BlurTimeKeyFrameValues[i] = src.BlurTimeKeyFrameValues[i];
			BlurTimeKeyFrameDeltas[i] = src.BlurTimeKeyFrameDeltas[i];
		}

		// Copy blur time randomizer table
		if (src.RandomBlurTimeEntries) {
			RandomBlurTimeEntries = new float [NumRandomBlurTimeEntriesMinus1 + 1];
			for (unsigned int j = 0; j <= NumRandomBlurTimeEntriesMinus1; j++) {
				RandomBlurTimeEntries[j] = src.RandomBlurTimeEntries[j];
			}
		}
	} else {
		BlurTimeKeyFrameValues = new float [1];
		BlurTimeKeyFrameValues[0] = src.BlurTimeKeyFrameValues[0];
	}


	// We do not add a ref for the emitter (see DTor for detailed explanation)
	// if (Emitter) Emitter->Add_Ref();

	// Set up new particle queue:
	NewParticleQueue = new NewParticleStruct[MaxNum];

	// Inputs don't need to be range-checked (emitter did that).
	Accel = src.Accel;
	HasAccel = src.HasAccel;

	switch (RenderMode)	
	{
	case W3D_EMITTER_RENDER_MODE_TRI_PARTICLES:
		{
			// Set up worldspace point group
			WWASSERT(src.PointGroup);
			PointGroup = new PointGroupClass();
			PointGroup->Set_Flag(PointGroupClass::TRANSFORM, true);
			PointGroup->Set_Texture(src.PointGroup->Peek_Texture());
			PointGroup->Set_Shader(src.PointGroup->Get_Shader());
			PointGroup->Set_Point_Mode(PointGroupClass::TRIS);
			PointGroup->Set_Frame_Row_Column_Count_Log2(src.PointGroup->Get_Frame_Row_Column_Count_Log2());
		}
		break;
	case W3D_EMITTER_RENDER_MODE_QUAD_PARTICLES:
		{
			// Set up worldspace point group
			WWASSERT(src.PointGroup);
			PointGroup = new PointGroupClass();
			PointGroup->Set_Flag(PointGroupClass::TRANSFORM, true);
			PointGroup->Set_Texture(src.PointGroup->Peek_Texture());
			PointGroup->Set_Shader(src.PointGroup->Get_Shader());
			PointGroup->Set_Point_Mode(PointGroupClass::QUADS);
			PointGroup->Set_Frame_Row_Column_Count_Log2(src.PointGroup->Get_Frame_Row_Column_Count_Log2());
		}
		break;
	case W3D_EMITTER_RENDER_MODE_LINE:
		{	
			WWASSERT(src.LineRenderer);
			LineRenderer = new SegLineRendererClass(*src.LineRenderer);
		}
		break;
	case W3D_EMITTER_RENDER_MODE_LINEGRP_TETRA:
		{
			WWASSERT(src.LineGroup);
			LineGroup=new LineGroupClass();
			LineGroup->Set_Flag(LineGroupClass::TRANSFORM, true);
			LineGroup->Set_Texture(src.LineGroup->Peek_Texture());
			LineGroup->Set_Shader(src.LineGroup->Get_Shader());
			LineGroup->Set_Line_Mode(LineGroupClass::TETRAHEDRON);
			TailPosition = NEW_REF( ShareBufferClass<Vector3> , (MaxNum) );
			// TODO: Change TailPosition to Kinematic state and add
			// tail positions to bounding box
			Set_Force_Visible(1);
		}
		break;
	case W3D_EMITTER_RENDER_MODE_LINEGRP_PRISM:
		{
			WWASSERT(src.LineGroup);
			LineGroup=new LineGroupClass();
			LineGroup->Set_Flag(LineGroupClass::TRANSFORM, true);
			LineGroup->Set_Texture(src.LineGroup->Peek_Texture());
			LineGroup->Set_Shader(src.LineGroup->Get_Shader());
			LineGroup->Set_Line_Mode(LineGroupClass::PRISM);
			TailPosition = NEW_REF( ShareBufferClass<Vector3> , (MaxNum) );
			// TODO: Change TailPosition to Kinematic state and add
			// tail positions to bounding box
			Set_Force_Visible(1);
		}
		break;
	default:
		WWASSERT(0);
		break;
	}

	// Set up circular buffer. Contents are not initialized because the
	// start/end indices currently indicate the buffer is empty.
	Position[0] = NEW_REF( ShareBufferClass<Vector3> , (MaxNum) );
	if (PingPongPosition) {
		Position[1] = NEW_REF( ShareBufferClass<Vector3> , (MaxNum) );
	}
	APT = NEW_REF( ShareBufferClass<unsigned int> , (MaxNum) );
	Velocity = new Vector3[MaxNum]; 
	TimeStamp = new unsigned int[MaxNum];

	// So that the object is ready for use after construction, we will
	// complete its initialization by initializing its cost and value arrays
	// according to a screen area of 1.
	int minlod = Calculate_Cost_Value_Arrays(1.0f, Value, Cost);

	// Ensure lod is no less than minimum allowed
	if (Get_LOD_Level() < minlod) Set_LOD_Level(minlod);

	// Update Global Count
	TotalActiveCount++;
}


ParticleBufferClass & ParticleBufferClass::operator = (const ParticleBufferClass & that)
{
	RenderObjClass::operator = (that);

	if (this != &that) {
		assert(0);	// TODO: if you hit this assert, please implement me !!!;-)
	}

	return * this;
}


ParticleBufferClass::~ParticleBufferClass(void)
{
	if (NewParticleQueue)				delete [] NewParticleQueue;
	if (ColorKeyFrameTimes)				delete [] ColorKeyFrameTimes;
	if (ColorKeyFrameValues)			delete [] ColorKeyFrameValues;
	if (ColorKeyFrameDeltas)			delete [] ColorKeyFrameDeltas;
	if (AlphaKeyFrameTimes)				delete [] AlphaKeyFrameTimes;
	if (AlphaKeyFrameValues)			delete [] AlphaKeyFrameValues;
	if (AlphaKeyFrameDeltas)			delete [] AlphaKeyFrameDeltas;
	if (SizeKeyFrameTimes)				delete [] SizeKeyFrameTimes;
	if (SizeKeyFrameValues)				delete [] SizeKeyFrameValues;
	if (SizeKeyFrameDeltas)				delete [] SizeKeyFrameDeltas;
	if (RotationKeyFrameTimes)			delete [] RotationKeyFrameTimes;
	if (RotationKeyFrameValues)		delete [] RotationKeyFrameValues;
	if (HalfRotationKeyFrameDeltas)	delete [] HalfRotationKeyFrameDeltas;
	if (OrientationKeyFrameValues)	delete [] OrientationKeyFrameValues;
	if (FrameKeyFrameTimes)				delete [] FrameKeyFrameTimes;
	if (FrameKeyFrameValues)			delete [] FrameKeyFrameValues;
	if (FrameKeyFrameDeltas)			delete [] FrameKeyFrameDeltas;
	if (BlurTimeKeyFrameTimes)			delete [] BlurTimeKeyFrameTimes;
	if (BlurTimeKeyFrameValues)		delete [] BlurTimeKeyFrameValues;
	if (BlurTimeKeyFrameDeltas)		delete [] BlurTimeKeyFrameDeltas;
	if (RandomColorEntries)				delete [] RandomColorEntries;
	if (RandomAlphaEntries)				delete [] RandomAlphaEntries;
	if (RandomSizeEntries)				delete [] RandomSizeEntries;
	if (RandomRotationEntries)			delete [] RandomRotationEntries;
	if (RandomOrientationEntries)		delete [] RandomOrientationEntries;
	if (RandomFrameEntries)				delete [] RandomFrameEntries;
	if (RandomBlurTimeEntries)			delete [] RandomBlurTimeEntries;
	
	if (PointGroup)						delete PointGroup;
	if (LineRenderer)						delete LineRenderer;
	if (LineGroup)							delete LineGroup;

	REF_PTR_RELEASE(Position[0]);
	REF_PTR_RELEASE(Position[1]);
	REF_PTR_RELEASE(Diffuse);
	REF_PTR_RELEASE(TailDiffuse);
	REF_PTR_RELEASE(Color);
	REF_PTR_RELEASE(Alpha);
	REF_PTR_RELEASE(Size);
	REF_PTR_RELEASE(Orientation);
	REF_PTR_RELEASE(Frame);
	REF_PTR_RELEASE(UCoord);
	REF_PTR_RELEASE(TailPosition);
	REF_PTR_RELEASE(APT);

	if (Velocity)	delete [] Velocity;
	if (TimeStamp)	delete [] TimeStamp;
	if (Emitter) {
		// We should not have an emitter at this point, since the emitter
		// should still have a live ref to us if it still exists which would
		// prevent us from getting killed.
		assert(0);
		// We do not release-ref the emitter pointer because we did not add a
		// ref for it to begin with; the ref is not needed (if the emitter gets
		// deleted it will tell us to clear our emitter pointer) and actually
		// harmful (if emitter and buffer each have refcounted pointers to the
		// other neither would ever get deleted).
		// Emitter->Release_Ref();
		Emitter = NULL;
	}	

	// Update Global Count
	TotalActiveCount--;
}


RenderObjClass * ParticleBufferClass::Clone(void) const
{
	return new ParticleBufferClass(*this);
}


int ParticleBufferClass::Get_Num_Polys(void) const
{
	// Currently in particle buffers, the cost happens to be equal to thwe polygon count.
	return (int)Get_Cost();
}

int ParticleBufferClass::Get_Particle_Count(void) const
{
	return NonNewNum + NewNum;
}

void ParticleBufferClass::Render(RenderInfoClass & rinfo)
{
	WWPROFILE("ParticleBuffer::Render");	

	unsigned int sort_level = SORT_LEVEL_NONE;

	if (!WW3D::Is_Sorting_Enabled())
		sort_level=Get_Shader().Guess_Sort_Level();

	if (WW3D::Are_Static_Sort_Lists_Enabled() && sort_level!=SORT_LEVEL_NONE) {		
		
		WW3D::Add_To_Static_Sort_List(this, sort_level);

	} else {
		// Ensure particles' kinematic state is updated
		Update_Kinematic_Particle_State();

		// Since we are rendering the particles, visual state needs to be updated (but not if the
		// entire particle buffer is decimated away)
		if (DecimationThreshold < LodCount - 1) {
			Update_Visual_Particle_State();
		}

		switch( RenderMode )
		{
		case W3D_EMITTER_RENDER_MODE_TRI_PARTICLES:
		case W3D_EMITTER_RENDER_MODE_QUAD_PARTICLES:
			Render_Particles(rinfo);
			break;
		case W3D_EMITTER_RENDER_MODE_LINE:
			Render_Line(rinfo);
			break;
		case W3D_EMITTER_RENDER_MODE_LINEGRP_TETRA:
		case W3D_EMITTER_RENDER_MODE_LINEGRP_PRISM:
			Render_Line_Group(rinfo);
			break;

		}
	}
}

void ParticleBufferClass::Generate_APT(ShareBufferClass <unsigned int> **apt,unsigned int &active_point_count)
{
	if (NonNewNum < (int)MaxNum || DecimationThreshold > 0) {
		// In the general case, a range in a circular buffer can be composed of up
		// to two subranges. Find the Start - End subranges.
		// This differs from other similar code segments because we want to access
		// the subranges in memory order (rather than in queue order) this time.
		unsigned int sub1_start;	// Start of subrange 1.
		unsigned int sub1_end;		// End of subrange 1.
		unsigned int sub2_start;	// Start of subrange 2.
		unsigned int sub2_end;		// End of subrange 2.
		unsigned int i;			// Loop index.
		if ((Start < End) || ((Start == End) && NonNewNum == 0)) {
			sub1_start = Start;
			sub1_end = End;
			sub2_start = End;
			sub2_end = End;
		} else {
			sub1_start = 0;
			sub1_end = End;
			sub2_start = Start;
			sub2_end = MaxNum;
		}
		// Generate APT:
		unsigned int *apt_ptr = APT->Get_Array();
		for (i = sub1_start; i < sub1_end; i++) {
			if (PermutationArray[i & 0xF] >= DecimationThreshold) {
				apt_ptr[active_point_count++] = i;
			}
		}
		for (i = sub2_start; i < sub2_end; i++) {
			if (PermutationArray[i & 0xF] >= DecimationThreshold) {
				apt_ptr[active_point_count++] = i;
			}
		}
		*apt = APT;
	} else {
		active_point_count = NonNewNum;
	}
}

void ParticleBufferClass::Combine_Color_And_Alpha()
{
	// Temporary array copying to combine diffuse and alpha to one array.
	if (Color || Alpha) {
		unsigned cnt=MaxNum;
		if (!Diffuse) {
			Diffuse = NEW_REF( ShareBufferClass<Vector4> , (MaxNum) );
		}
		if (Color && Alpha) {
			VectorProcessorClass::Copy(
				Diffuse->Get_Array(),
				Color->Get_Array(),
				Alpha->Get_Array(),
				cnt);
		}
		else if (Color) {
			VectorProcessorClass::Copy(
				Diffuse->Get_Array(),
				Color->Get_Array(),
				1.0f,
				cnt);
		}
		else {
			VectorProcessorClass::Copy(
				Diffuse->Get_Array(),
				Vector3(1.0f,1.0f,1.0f),
				Alpha->Get_Array(),
				cnt);
		}
		VectorProcessorClass::Clamp(
			Diffuse->Get_Array(),
			Diffuse->Get_Array(),
			0.0f,
			1.0f,
			cnt);
	}
	else if (Diffuse) {
		Diffuse->Release_Ref();
		Diffuse=NULL;
	}
}

void ParticleBufferClass::Render_Particles(RenderInfoClass & rinfo)
{
	// If the number of active points is less than the maximum or we need to decimate particles
	// (for LOD purposes), build the active point table:
	ShareBufferClass<unsigned int> *apt = NULL;

	unsigned int active_point_count = 0;

	Generate_APT(&apt,active_point_count);	

	// Set color, alpha, size defaults if array not present:
	if (!Color) {
		PointGroup->Set_Point_Color(ColorKeyFrameValues[0]);
	}
	if (!Alpha) {
		PointGroup->Set_Point_Alpha(AlphaKeyFrameValues[0]);
	}
	if (!Size) {
		PointGroup->Set_Point_Size(SizeKeyFrameValues[0]);
	}
	if (!Orientation) {
		// The rotation keyframes are used to derive the orientation indirectly, as well as the
		// starting orientation randomizer. If there is no Orientation array that means both are
		// absent so the orientation should just be set to 0.
		PointGroup->Set_Point_Orientation(0);
	}
	if (!Frame) {
		PointGroup->Set_Point_Frame(((int)(FrameKeyFrameValues[0])) & 0xFF);
	}


	// Pass the point buffer to the point group and render it.
	// If we are using pingpong position buffers pass the right one
	int pingpong = 0;
	if (PingPongPosition) {
		pingpong = WW3D::Get_Frame_Count() & 0x1;
	}

	Combine_Color_And_Alpha();

	PointGroup->Set_Arrays(Position[pingpong], Diffuse, apt, Size, Orientation, Frame, active_point_count);
	Update_Bounding_Box();	
	PointGroup->Render(rinfo);	
}


void ParticleBufferClass::Render_Line(RenderInfoClass & rinfo)
{
	// Look up the array to use
	int pingpong = 0;
	if (PingPongPosition) {
		pingpong = WW3D::Get_Frame_Count() & 0x1;
	}

	// Unroll the circular buffer while skipping LOD'd particles
	static SimpleDynVecClass<Vector3> tmp_points;
	Vector3 * positions = Position[pingpong]->Get_Array();

	unsigned int sub1_end;		// End of subrange 1.
	unsigned int sub2_start;	// Start of subrange 2.
	unsigned int i;				// Loop index.

	if ((Start < End) || ((Start == End) && NonNewNum ==0)) {
		sub1_end = End;
		sub2_start = End;
	} else {
		sub1_end = MaxNum;
		sub2_start = 0;
	}

	tmp_points.Delete_All(false);
	
	for (i = Start; i < sub1_end; i++) {
		if (PermutationArray[i & 0xF] >= DecimationThreshold) {
			tmp_points.Add(positions[i]);
		}
	}
	for (i = sub2_start; i < End; i++) {
		if (PermutationArray[i & 0xF] >= DecimationThreshold) {
			tmp_points.Add(positions[i]);
		}
	}

	// If we got any points, render them
	if (tmp_points.Count() > 0) {
		SphereClass bounding_sphere;
		Get_Obj_Space_Bounding_Sphere(bounding_sphere);
		LineRenderer->Render(rinfo,
									Transform,
									tmp_points.Count(),
									&(tmp_points[0]),
									bounding_sphere);
	}
}

void ParticleBufferClass::Render_Line_Group(RenderInfoClass & rinfo)
{
	// If the number of active points is less than the maximum or we need to decimate particles
	// (for LOD purposes), build the active point table:
	ShareBufferClass<unsigned int> *apt = NULL;

	unsigned int active_point_count = 0;	

	Generate_APT(&apt,active_point_count);	

	// Set color, alpha, size defaults if array not present:
	if (!Color) {
		LineGroup->Set_Line_Color(ColorKeyFrameValues[0]);
	}
	if (!Alpha) {
		LineGroup->Set_Line_Alpha(AlphaKeyFrameValues[0]);
	}
	if (!Size) {
		LineGroup->Set_Line_Size(SizeKeyFrameValues[0]);
	}
	if (!Frame) {
		LineGroup->Set_Line_UCoord(FrameKeyFrameValues[0]);
	}


	// Pass the point buffer to the line group and render it.
	// If we are using pingpong position buffers pass the right one
	int pingpong = 0;
	if (PingPongPosition) {
		pingpong = WW3D::Get_Frame_Count() & 0x1;
	}

	Combine_Color_And_Alpha();

	TailDiffuseTypeEnum tailtype=Determine_Tail_Diffuse();

	switch (tailtype)
	{
	case BLACK:
		REF_PTR_RELEASE(TailDiffuse);
		DefaultTailDiffuse.Set(0,0,0,0);
		break;
	case WHITE:
		REF_PTR_RELEASE(TailDiffuse);
		DefaultTailDiffuse.Set(1,1,1,1);
		break;
	case SAME_AS_HEAD_ALPHA_ZERO:
		// if head is all one color, set tail the same way
		if (!Diffuse) {
			REF_PTR_RELEASE(TailDiffuse);
			DefaultTailDiffuse.Set(ColorKeyFrameValues[0].X,ColorKeyFrameValues[0].Y,ColorKeyFrameValues[0].Z,0);
		} else {
			// otherwise allocate and copy tail diffuse
			if (!TailDiffuse) TailDiffuse=NEW_REF(ShareBufferClass<Vector4>,(MaxNum));
			for (unsigned int i=0; i<MaxNum; i++) {
				Vector4 elt=Diffuse->Get_Element(i);				
				elt.W=0;
				TailDiffuse->Set_Element(i,elt);
			}
		}
		break;
	case SAME_AS_HEAD:
		// if head is all one color, set tail the same way
		if (!Diffuse) {
			REF_PTR_RELEASE(TailDiffuse);
			DefaultTailDiffuse.Set(ColorKeyFrameValues[0].X,ColorKeyFrameValues[0].Y,ColorKeyFrameValues[0].Z,AlphaKeyFrameValues[0]);
		} else {
			// otherwise allocate and copy tail diffuse
			if (!TailDiffuse) TailDiffuse=NEW_REF(ShareBufferClass<Vector4>,(MaxNum));
			VectorProcessorClass::Copy(TailDiffuse->Get_Array(),Diffuse->Get_Array(),MaxNum);
		}
		break;
	default:
		WWASSERT(0);
		break;
	}

	if (!TailDiffuse)
		LineGroup->Set_Tail_Diffuse(DefaultTailDiffuse);
	
	LineGroup->Set_Arrays(Position[pingpong], TailPosition,Diffuse,TailDiffuse, apt, Size, UCoord, active_point_count);
	Update_Bounding_Box();	
	LineGroup->Render(rinfo);	
}

// Scales the size of the individual particles but doesn't affect their
// position (and therefore the size of the particle system as a whole)
void ParticleBufferClass::Scale(float scale)
{
	// Scale all size keyframes, keyframe deltas, random size entries,
	// MaxSize and SizeRandom.
	unsigned int i;
	for (i = 0; i < NumSizeKeyFrames; i++) {
		SizeKeyFrameValues[i] *= scale;
		SizeKeyFrameDeltas[i] *= scale;
	}
	if (RandomSizeEntries) {
		for (i = 0; i <= NumRandomSizeEntriesMinus1; i++) {
			RandomSizeEntries[i] *= scale;
		}
	}
	MaxSize *= scale;
	SizeRandom *= scale;
}





// The particle buffer never receives a Set_Transform/Position call,
// evem though its bounding volume changes. Since bounding volume
// invalidations ordinarily occur when these functions are called,
// the cached bounding volumes will not be invalidated unless we do
// it elsewhere (such as here). We also need to call the particle
// emitter's Emit() function (done here to avoid order dependence).
void ParticleBufferClass::On_Frame_Update(void)
{
	Invalidate_Cached_Bounding_Volumes();
	if (Emitter) {
		Emitter->Emit();
	}
	
	if (Is_Complete()) {
		WWASSERT(Scene);
		Scene->Register(this,SceneClass::RELEASE);
	}
}


void ParticleBufferClass::Notify_Added(SceneClass * scene)
{
	RenderObjClass::Notify_Added(scene);
	scene->Register(this,SceneClass::ON_FRAME_UPDATE);
}


void ParticleBufferClass::Notify_Removed(SceneClass * scene)
{
	scene->Unregister(this,SceneClass::ON_FRAME_UPDATE);
	RenderObjClass::Notify_Removed(scene);
}


void ParticleBufferClass::Get_Obj_Space_Bounding_Sphere(SphereClass & sphere) const
{
	// This ugly cast is done because the alternative is to make everything
	// in the class mutable, which does not seem like a good solution
	// (Update_Bounding_Box can potentially update the particle state)
	((ParticleBufferClass *)this)->Update_Bounding_Box();

	// The particle buffer's transform is always identity, so
	// objspace == worldspace.

	// Wrap sphere outside bounding box:
	sphere.Center = BoundingBox.Center;
	sphere.Radius = BoundingBox.Extent.Length();
}


void ParticleBufferClass::Get_Obj_Space_Bounding_Box(AABoxClass & box) const
{
	// This ugly cast is done because the alternative is to make everything
	// in the class mutable, which does not seem like a good solution
	// (Update_Bounding_Box can potentially update the particle state).
	((ParticleBufferClass *)this)->Update_Bounding_Box();

	// The particle buffer's transform is always identity, so
	// objspace == worldspace.
	box = BoundingBox;
}


void ParticleBufferClass::Prepare_LOD(CameraClass &camera)
{
	if (Is_Not_Hidden_At_All() == false) {
		return;
	}

	// Estimate the screen area of the particle buffer. We shall take the lesser of two
	// metrics: the standard bounding-sphere projection (which for many particle systems may
	// grossly overestimate the actual screen area), and a measurement based on the screen area of
	// individual particles times the maximum number of particles (in the case of densely
	// overlapping particles this metric can also give numbers which are too high, which is why we
	// use the bounding sphere as backup). Note - to find the area of individual particles we
	// treat them as all being the maximum size and being in the center of the bounding sphere).

	Vector3 cam = camera.Get_Position();
	ViewportClass viewport = camera.Get_Viewport();
	Vector2 vpr_min, vpr_max;
	camera.Get_View_Plane(vpr_min, vpr_max);
	float width_factor = viewport.Width() / (vpr_max.X - vpr_min.X);
	float height_factor = viewport.Height() / (vpr_max.Y - vpr_min.Y);

	const SphereClass & sphere = Get_Bounding_Sphere();
	float dist = (sphere.Center - cam).Length();
	float bounding_sphere_projected_radius = 0.0f;
	float particle_projected_radius = 0.0f;
	if (dist) {
		float oo_dist = 1.0f / dist;
		bounding_sphere_projected_radius = sphere.Radius * oo_dist;
		particle_projected_radius = MaxSize * oo_dist;
	}

	float bs_rad_sq = bounding_sphere_projected_radius * bounding_sphere_projected_radius;
	float p_rad_sq = particle_projected_radius * particle_projected_radius * MaxNum;
	float proj_area = WWMATH_PI * MIN(bs_rad_sq, p_rad_sq) * width_factor * height_factor;

	// Filter the area over time so we don't get as many pops in the LOD algorithm
	ProjectedArea = 0.9f * ProjectedArea + 0.1f * proj_area;

	int minlod = Calculate_Cost_Value_Arrays(ProjectedArea, Value, Cost);

	// Ensure lod is no less than minimum allowed
	if (Get_LOD_Level() < minlod) Set_LOD_Level(minlod);

	PredictiveLODOptimizerClass::Add_Object(this);
}

void ParticleBufferClass::Increment_LOD(void)
{
	if (DecimationThreshold > 0) DecimationThreshold--;
}

void ParticleBufferClass::Decrement_LOD(void)
{
	if (DecimationThreshold < LodCount) DecimationThreshold++;
}

float ParticleBufferClass::Get_Cost(void) const
{
	return(Cost[(LodCount - 1) - DecimationThreshold]);
}

float ParticleBufferClass::Get_Value(void) const
{
	return(Value[(LodCount - 1) - DecimationThreshold]);
}

float ParticleBufferClass::Get_Post_Increment_Value(void) const
{
	return(Value[LodCount - DecimationThreshold]);
}

void ParticleBufferClass::Set_LOD_Level(int lod)
{
	lod = Bound(lod, 0, (int)LodCount);
	DecimationThreshold = (LodCount - 1) - lod;
}

int ParticleBufferClass::Get_LOD_Level(void) const
{
	return((LodCount - 1) - DecimationThreshold);
}

int ParticleBufferClass::Get_LOD_Count(void) const
{
	return LodCount;
}

int ParticleBufferClass::Calculate_Cost_Value_Arrays(float screen_area, float *values, float *costs) const
{
	unsigned int lod = 0;

	// Calculate Cost heuristic for each LOD (we currently ignore pixel costs for particle systems)
	// The cost factor is later multiplied by the LOD level. The LOD level is the numerator of the
	// fraction of particles rendered, where 16 is the denominator. For this reason the cost factor
	// is based on a 1/16 (0.0625) of the total.
	float cost_factor=0.0f;
	switch (RenderMode)
	{
	case W3D_EMITTER_RENDER_MODE_TRI_PARTICLES:
		cost_factor = (float)MaxNum * 0.0625f;
		break;
	case W3D_EMITTER_RENDER_MODE_QUAD_PARTICLES:
		cost_factor = (float)MaxNum * 2.0f * 0.0625f;
		break;
	case W3D_EMITTER_RENDER_MODE_LINE:
		cost_factor = (float) (2*MaxNum-1) * 0.0625f;
		break;
	case W3D_EMITTER_RENDER_MODE_LINEGRP_TETRA:
		cost_factor = (float)MaxNum * 4.0f * 0.0625f;
		break;
	case W3D_EMITTER_RENDER_MODE_LINEGRP_PRISM:
		cost_factor = (float)MaxNum * 8.0f * 0.0625f;
		break;
	}	
	for (lod = 0; lod < LodCount; lod++) {
		costs[lod] = cost_factor * (float)lod;
		// If cost is zero set it to a small nonzero amount to avoid divisions by zero.
		costs[lod] = (costs[lod] != 0) ? costs[lod] : 0.000001f;
	}

	// Calculate Value heuristic. First, all LOD levels for which
	// MaxScreenSize is smaller than screen_area have their Value set to
	// AT_MIN_LOD, as well as the first LOD after that (unless there are no
	// other LODs):
	for (lod = 0;  lod < LodCount && LODMaxScreenSizes[lod] < screen_area; lod++) {
		values[lod] = AT_MIN_LOD;
	}

	if (lod >= LodCount) {
		lod = LodCount - 1;
	} else {
		values[lod] = AT_MIN_LOD;
	}

	// Now lod is the lowest allowed - return this value.
	int minlod = lod;

	// Calculate Value heuristic for any remaining LODs based on normalized screen area:
	lod++;
	for (; lod < LodCount; lod++) {
		// Currently the cost happens to be equal to the poly count. We use a floating-
		// point poly count since costs[] contains an approximation to the true polycount which may
		// be less than one in some cases (we want to avoid 0 polycounts except for true null LODs)
		float polycount = costs[lod];
		float benefit_factor = (polycount > WWMATH_EPSILON) ? (1 - (0.5f / (polycount * polycount))) : 0.0f;
		values[lod] = (benefit_factor * screen_area * LodBias) / costs[lod];
	}
	values[LodCount] = AT_MAX_LOD; 	// Post-inc value will flag max LOD.

	return minlod;
}

		
void ParticleBufferClass::Reset_Colors(ParticlePropertyStruct<Vector3> &new_props)
{

	unsigned int i;	// Used in loops
	unsigned int ui_previous_key_time = 0;
	unsigned int ui_current_key_time = 0;

	ColorRandom = new_props.Rand;

	// If the randomizer is effectively zero and there are no keyframes, then we just create a
	// values array with one entry and store the starting value in it (the keyframes and random
	// table will not be used in this case).
	static const float eps_byte = 0.0038f;	// Epsilon value - less than 1/255
	bool color_rand_zero	= (fabs(new_props.Rand.X) < eps_byte && fabs(new_props.Rand.Y) < eps_byte && fabs(new_props.Rand.Z) < eps_byte);
	if (color_rand_zero && new_props.NumKeyFrames == 0) {

		// Release Color, ColorKeyFrameTimes and ColorKeyFrameDeltas if present. Reuse
		// ColorKeyFrameValues if the right size, otherwise release and reallocate.
		if (Color) {
			Color->Release_Ref();
			Color = NULL;
		}
		if (ColorKeyFrameTimes) {
			delete [] ColorKeyFrameTimes;
			ColorKeyFrameTimes = NULL;
		}
		if (ColorKeyFrameDeltas) {
			delete [] ColorKeyFrameDeltas;
			ColorKeyFrameDeltas = NULL;
		}
		if (ColorKeyFrameValues) {
			if (NumColorKeyFrames > 1) {
				delete [] ColorKeyFrameValues;
				ColorKeyFrameValues = new Vector3 [1];
			}
		} else {
			ColorKeyFrameValues = new Vector3 [1];
		}

		NumColorKeyFrames = 0;
		NumRandomColorEntriesMinus1 = 0;
		ColorKeyFrameValues[0] = new_props.Start;

	} else {

		// Create the color array if not present
		if (!Color) {
			Color = NEW_REF( ShareBufferClass<Vector3> , (MaxNum) );
		}

		// Check times of color keyframes (each keytime must be larger than the
		// previous one by at least a millisecond, and we stop at the first
		// keytime of MaxAge or larger. (If all keyframes below MaxAge, color is
		// constant during the last segment between last keyframe and MaxAge).
		ui_previous_key_time = 0;
		unsigned int ckey;
		for (ckey = 0; ckey < new_props.NumKeyFrames; ckey++) {
			ui_current_key_time = (unsigned int)(new_props.KeyTimes[ckey] * 1000.0f);
			WWASSERT(ui_current_key_time > ui_previous_key_time);
			if (ui_current_key_time >= MaxAge) break;
			ui_previous_key_time = ui_current_key_time;
		}
		bool color_constant_at_end = (ckey == new_props.NumKeyFrames);

		// Reuse ColorKeyFrameValues, ColorKeyFrameTimes and ColorKeyFrameDeltas if the right size,
		// otherwise release and reallocate.
		unsigned int new_num_color_key_frames = ckey + 1;// Includes start keyframe (keytime == 0).
		if (new_num_color_key_frames != NumColorKeyFrames) {

			if (ColorKeyFrameTimes) {
				delete [] ColorKeyFrameTimes;
				ColorKeyFrameTimes = NULL;
			}
			if (ColorKeyFrameValues) {
				delete [] ColorKeyFrameValues;
				ColorKeyFrameValues = NULL;
			}
			if (ColorKeyFrameDeltas) {
				delete [] ColorKeyFrameDeltas;
				ColorKeyFrameDeltas = NULL;
			}

			NumColorKeyFrames = new_num_color_key_frames;	
			ColorKeyFrameTimes = new unsigned int [NumColorKeyFrames];
			ColorKeyFrameValues = new Vector3 [NumColorKeyFrames];
			ColorKeyFrameDeltas = new Vector3 [NumColorKeyFrames];
		}

		// Set color keyframes (deltas will be set later)
		ColorKeyFrameTimes[0] = 0;
		ColorKeyFrameValues[0] = new_props.Start;
		for (i = 1; i < NumColorKeyFrames; i++) {
			unsigned int im1 = i - 1;
			ColorKeyFrameTimes[i] = (unsigned int)(new_props.KeyTimes[im1] * 1000.0f);
			ColorKeyFrameValues[i] = new_props.Values[im1];
		}

		// Do deltas for all color keyframes except last
		for (i = 0; i < NumColorKeyFrames - 1; i++) {
			ColorKeyFrameDeltas[i]	= (ColorKeyFrameValues[i + 1] - ColorKeyFrameValues[i]) /
				(float)(ColorKeyFrameTimes[i + 1] - ColorKeyFrameTimes[i]);
		}

		// Do delta for last color keyframe (i is NumColorKeyFrames - 1)
		if (color_constant_at_end) {
			ColorKeyFrameDeltas[i].Set(0.0, 0.0, 0.0);
		} else {
			// This is OK because if color_constant_at_end is false, NumColorKeyFrames is equal or
			// smaller than color.NumKeyFrames so color.Values[NumColorKeyFrames - 1] and
			// color.KeyTimes[NumColorKeyFrames - 1] exist.
			ColorKeyFrameDeltas[i]	= (new_props.Values[i] - ColorKeyFrameValues[i]) /
				(new_props.KeyTimes[i] * 1000.0f - (float)ColorKeyFrameTimes[i]);
		}

		// Set up color randomizer table

		if (color_rand_zero) {

			if (RandomColorEntries) {
				// Reuse RandomColorEntries if the right size, otherwise release and reallocate.
				if (NumRandomColorEntriesMinus1 != 0) {
					delete [] RandomColorEntries;
					RandomColorEntries = new Vector3 [1];
				}
			} else {
				RandomColorEntries = new Vector3 [1];
			}

			NumRandomColorEntriesMinus1 = 0;
			RandomColorEntries[0].X = 0.0f;
			RandomColorEntries[0].Y = 0.0f;
			RandomColorEntries[0].Z = 0.0f;
		} else {

			// Default size of randomizer tables (tables for non-zero randomizers will be this size)
			unsigned int pot_num = Find_POT(MaxNum);
			unsigned int default_randomizer_entries = MIN(pot_num, MAX_RANDOM_ENTRIES);

			if (RandomColorEntries) {
				// Reuse RandomColorEntries if the right size, otherwise release and reallocate.
				if (NumRandomColorEntriesMinus1 != (default_randomizer_entries - 1)) {
					delete [] RandomColorEntries;
					RandomColorEntries = new Vector3 [default_randomizer_entries];
				}
			} else {
				RandomColorEntries = new Vector3 [default_randomizer_entries];
			}

			NumRandomColorEntriesMinus1 = default_randomizer_entries - 1;

			float rscale = new_props.Rand.X * oo_intmax;
			float gscale = new_props.Rand.Y * oo_intmax;
			float bscale = new_props.Rand.Z * oo_intmax;
			for (unsigned int j = 0; j <= NumRandomColorEntriesMinus1; j++) {
				RandomColorEntries[j] = Vector3(rand_gen * rscale, rand_gen * gscale, rand_gen * bscale);
			}
		}
	}
}


void ParticleBufferClass::Reset_Opacity(ParticlePropertyStruct<float> &new_props)
{
	unsigned int i;	// Used in loops
	unsigned int ui_previous_key_time = 0;
	unsigned int ui_current_key_time = 0;

	OpacityRandom = new_props.Rand;

	// If the randomizer is effectively zero and there are no keyframes, then we just create a
	// values array with one entry and store the starting value in it (the keyframes and random
	// table will not be used in this case).
	static const float eps_byte = 0.0038f;	// Epsilon value - less than 1/255
	bool alpha_rand_zero	= (fabs(new_props.Rand) < eps_byte);
	if (alpha_rand_zero && new_props.NumKeyFrames == 0) {

		// Release Alpha, AlphaKeyFrameTimes and AlphaKeyFrameDeltas if present. Reuse
		// AlphaKeyFrameValues if the right size, otherwise release and reallocate.
		if (Alpha) {
			Alpha->Release_Ref();
			Alpha = NULL;
		}
		if (AlphaKeyFrameTimes) {
			delete [] AlphaKeyFrameTimes;
			AlphaKeyFrameTimes = NULL;
		}
		if (AlphaKeyFrameDeltas) {
			delete [] AlphaKeyFrameDeltas;
			AlphaKeyFrameDeltas = NULL;
		}
		if (AlphaKeyFrameValues) {
			if (NumAlphaKeyFrames > 1) {
				delete [] AlphaKeyFrameValues;
				AlphaKeyFrameValues = new float [1];
			}
		} else {
			AlphaKeyFrameValues = new float [1];
		}

		NumAlphaKeyFrames = 0;
		NumRandomAlphaEntriesMinus1 = 0;
		AlphaKeyFrameValues[0] = new_props.Start;

	} else {

		// Create the alpha array if not present
		if (!Alpha) {
			Alpha = NEW_REF( ShareBufferClass<float> , (MaxNum) );
		}

		// Check times of opacity keyframes (each keytime must be larger than the
		// previous one by at least a millisecond, and we stop at the first
		// keytime of MaxAge or larger. (If all keyframes below MaxAge, alpha is
		// constant during the last segment between last keyframe and MaxAge).
		ui_previous_key_time = 0;
		unsigned int akey;
		for (akey = 0; akey < new_props.NumKeyFrames; akey++) {
			ui_current_key_time = (unsigned int)(new_props.KeyTimes[akey] * 1000.0f);
			WWASSERT(ui_current_key_time > ui_previous_key_time);
			if (ui_current_key_time >= MaxAge) break;
			ui_previous_key_time = ui_current_key_time;
		}
		bool alpha_constant_at_end = (akey == new_props.NumKeyFrames);

		// Reuse AlphaKeyFrameValues, AlphaKeyFrameTimes and AlphaKeyFrameDeltas if the right size,
		// otherwise release and reallocate.
		unsigned int new_num_alpha_key_frames = akey + 1;// Includes start keyframe (keytime == 0).
		if (new_num_alpha_key_frames != NumAlphaKeyFrames) {

			if (AlphaKeyFrameTimes) {
				delete [] AlphaKeyFrameTimes;
				AlphaKeyFrameTimes = NULL;
			}
			if (AlphaKeyFrameValues) {
				delete [] AlphaKeyFrameValues;
				AlphaKeyFrameValues = NULL;
			}
			if (AlphaKeyFrameDeltas) {
				delete [] AlphaKeyFrameDeltas;
				AlphaKeyFrameDeltas = NULL;
			}

			NumAlphaKeyFrames = new_num_alpha_key_frames;	
			AlphaKeyFrameTimes = new unsigned int [NumAlphaKeyFrames];
			AlphaKeyFrameValues = new float [NumAlphaKeyFrames];
			AlphaKeyFrameDeltas = new float [NumAlphaKeyFrames];
		}

		// Set alpha keyframes (deltas will be set later)
		AlphaKeyFrameTimes[0] = 0;
		AlphaKeyFrameValues[0] = new_props.Start;
		for (i = 1; i < NumAlphaKeyFrames; i++) {
			unsigned int im1 = i - 1;
			AlphaKeyFrameTimes[i] = (unsigned int)(new_props.KeyTimes[im1] * 1000.0f);
			AlphaKeyFrameValues[i] = new_props.Values[im1];
		}

		// Do deltas for all alpha keyframes except last
		for (i = 0; i < NumAlphaKeyFrames - 1; i++) {
			AlphaKeyFrameDeltas[i]	= (AlphaKeyFrameValues[i + 1] - AlphaKeyFrameValues[i]) /
				(float)(AlphaKeyFrameTimes[i + 1] - AlphaKeyFrameTimes[i]);
		}

		// Do delta for last alpha keyframe (i is NumAlphaKeyFrames - 1)
		if (alpha_constant_at_end) {
			AlphaKeyFrameDeltas[i] = 0.0f;
		} else {
			// This is OK because if alpha_constant_at_end is false, NumAlphaKeyFrames is equal or
			// smaller than opacity.NumKeyFrames so opacity.Values[NumAlphaKeyFrames - 1] and
			// opacity.KeyTimes[NumAlphaKeyFrames - 1] exist.
			AlphaKeyFrameDeltas[i]	= (new_props.Values[i] - AlphaKeyFrameValues[i]) /
				(new_props.KeyTimes[i] * 1000.0f - (float)AlphaKeyFrameTimes[i]);
		}

		// Set up alpha randomizer table

		if (alpha_rand_zero) {

			if (RandomAlphaEntries) {
				// Reuse RandomAlphaEntries if the right size, otherwise release and reallocate.
				if (NumRandomAlphaEntriesMinus1 != 0) {
					delete [] RandomAlphaEntries;
					RandomAlphaEntries = new float [1];
				}
			} else {
				RandomAlphaEntries = new float [1];
			}

			NumRandomAlphaEntriesMinus1 = 0;
			RandomAlphaEntries[0] = 0.0f;
		} else {

			// Default size of randomizer tables (tables for non-zero randomizers will be this size)
			unsigned int pot_num = Find_POT(MaxNum);
			unsigned int default_randomizer_entries = MIN(pot_num, MAX_RANDOM_ENTRIES);

			if (RandomAlphaEntries) {
				// Reuse RandomAlphaEntries if the right size, otherwise release and reallocate.
				if (NumRandomAlphaEntriesMinus1 != (default_randomizer_entries - 1)) {
					delete [] RandomAlphaEntries;
					RandomAlphaEntries = new float [default_randomizer_entries];
				}
			} else {
				RandomAlphaEntries = new float [default_randomizer_entries];
			}

			NumRandomAlphaEntriesMinus1 = default_randomizer_entries - 1;

			float ascale = new_props.Rand * oo_intmax;
			for (unsigned int j = 0; j <= NumRandomAlphaEntriesMinus1; j++) {
				RandomAlphaEntries[j] = rand_gen * ascale;
			}
		}
	}
}


void ParticleBufferClass::Reset_Size(ParticlePropertyStruct<float> &new_props)
{

	unsigned int i;	// Used in loops
	unsigned int ui_previous_key_time = 0;
	unsigned int ui_current_key_time = 0;

	SizeRandom = new_props.Rand;

	// If the randomizer is effectively zero and there are no keyframes, then we just create a
	// values array with one entry and store the starting value in it (the keyframes and random
	// table will not be used in this case).
	static const float eps_size = 1.0e-12f;	// Size scale unknown so must use very small epsilon
	bool size_rand_zero	= (fabs(new_props.Rand) < eps_size);
	if (size_rand_zero && new_props.NumKeyFrames == 0) {

		// Release Size, SizeKeyFrameTimes and SizeaKeyFrameDeltas if present. Reuse
		// SizeKeyFrameValues if the right size, otherwise release and reallocate.
		if (Size) {
			Size->Release_Ref();
			Size = NULL;
		}
		if (SizeKeyFrameTimes) {
			delete [] SizeKeyFrameTimes;
			SizeKeyFrameTimes = NULL;
		}
		if (SizeKeyFrameDeltas) {
			delete [] SizeKeyFrameDeltas;
			SizeKeyFrameDeltas = NULL;
		}
		if (SizeKeyFrameValues) {
			if (NumSizeKeyFrames > 1) {
				delete [] SizeKeyFrameValues;
				SizeKeyFrameValues = new float [1];
			}
		} else {
			SizeKeyFrameValues = new float [1];
		}

		NumSizeKeyFrames = 0;
		NumRandomSizeEntriesMinus1 = 0;
		SizeKeyFrameValues[0] = new_props.Start;
		MaxSize = SizeKeyFrameValues[0];
	} else {

		// Create the size array if not present
		if (!Size) {
			Size = NEW_REF( ShareBufferClass<float> , (MaxNum) );
		}

		// Check times of size keyframes (each keytime must be larger than the
		// previous one by at least a millisecond, and we stop at the first
		// keytime of MaxAge or larger. (If all keyframes below MaxAge, size is
		// constant during the last segment between last keyframe and MaxAge).
		ui_previous_key_time = 0;
		unsigned int skey;
		for (skey = 0; skey < new_props.NumKeyFrames; skey++) {
			ui_current_key_time = (unsigned int)(new_props.KeyTimes[skey] * 1000.0f);
			WWASSERT(ui_current_key_time > ui_previous_key_time);
			if (ui_current_key_time >= MaxAge) break;
			ui_previous_key_time = ui_current_key_time;
		}
		bool size_constant_at_end = (skey == new_props.NumKeyFrames);

		// Reuse SizeKeyFrameValues, SizeKeyFrameTimes and SizeKeyFrameDeltas if the right size,
		// otherwise release and reallocate.
		unsigned int new_num_size_key_frames = skey + 1;// Includes start keyframe (keytime == 0).
		if (new_num_size_key_frames != NumSizeKeyFrames) {

			if (SizeKeyFrameTimes) {
				delete [] SizeKeyFrameTimes;
				SizeKeyFrameTimes = NULL;
			}
			if (SizeKeyFrameValues) {
				delete [] SizeKeyFrameValues;
				SizeKeyFrameValues = NULL;
			}
			if (SizeKeyFrameDeltas) {
				delete [] SizeKeyFrameDeltas;
				SizeKeyFrameDeltas = NULL;
			}

			NumSizeKeyFrames = new_num_size_key_frames;	
			SizeKeyFrameTimes = new unsigned int [NumSizeKeyFrames];
			SizeKeyFrameValues = new float [NumSizeKeyFrames];
			SizeKeyFrameDeltas = new float [NumSizeKeyFrames];
		}

		// Set size keyframes (deltas will be set later)
		SizeKeyFrameTimes[0] = 0;
		SizeKeyFrameValues[0] = new_props.Start;
		for (i = 1; i < NumSizeKeyFrames; i++) {
			unsigned int im1 = i - 1;
			SizeKeyFrameTimes[i] = (unsigned int)(new_props.KeyTimes[im1] * 1000.0f);
			SizeKeyFrameValues[i] = new_props.Values[im1];
		}

		// Do deltas for all size keyframes except last
		for (i = 0; i < NumSizeKeyFrames - 1; i++) {
			SizeKeyFrameDeltas[i]	= (SizeKeyFrameValues[i + 1] - SizeKeyFrameValues[i]) /
				(float)(SizeKeyFrameTimes[i + 1] - SizeKeyFrameTimes[i]);
		}

		// Do delta for last size keyframe (i is NumSizeKeyFrames - 1)
		if (size_constant_at_end) {
			SizeKeyFrameDeltas[i] = 0.0f;
		} else {
			// This is OK because if size_constant_at_end is false, NumSizeKeyFrames is equal or
			// smaller than new_props.NumKeyFrames so new_props.Values[NumSizeKeyFrames - 1] and
			// new_props.KeyTimes[NumSizeKeyFrames - 1] exist.
			SizeKeyFrameDeltas[i] = (new_props.Values[i] - SizeKeyFrameValues[i]) /
				(new_props.KeyTimes[i] * 1000.0f - (float)SizeKeyFrameTimes[i]);
		}

		// Find maximum size (for BBox updates)
		MaxSize = SizeKeyFrameValues[0];
		for (i = 1; i < NumSizeKeyFrames; i++) {
			MaxSize = MAX(MaxSize, SizeKeyFrameValues[i]);
		}
		// If last delta is positive, there may be a larger size keyframe:
		float last_size = SizeKeyFrameValues[NumSizeKeyFrames - 1] + SizeKeyFrameDeltas[NumSizeKeyFrames - 1] *
			(float)(MaxAge - SizeKeyFrameTimes[NumSizeKeyFrames - 1]);
		MaxSize = MAX(MaxSize, last_size);
		MaxSize += fabs(new_props.Rand);

		// Set up size randomizer table

		if (size_rand_zero) {

			if (RandomSizeEntries) {
				// Reuse RandomSizeEntries if the right size, otherwise release and reallocate.
				if (NumRandomSizeEntriesMinus1 != 0) {
					delete [] RandomSizeEntries;
					RandomSizeEntries = new float [1];
				}
			} else {
				RandomSizeEntries = new float [1];
			}

			NumRandomSizeEntriesMinus1 = 0;
			RandomSizeEntries[0] = 0.0f;
		} else {

			// Default size of randomizer tables (tables for non-zero randomizers will be this size)
			unsigned int pot_num = Find_POT(MaxNum);
			unsigned int default_randomizer_entries = MIN(pot_num, MAX_RANDOM_ENTRIES);

			if (RandomSizeEntries) {
				// Reuse RandomSizeEntries if the right size, otherwise release and reallocate.
				if (NumRandomSizeEntriesMinus1 != (default_randomizer_entries - 1)) {
					delete [] RandomSizeEntries;
					RandomSizeEntries = new float [default_randomizer_entries];
				}
			} else {
				RandomSizeEntries = new float [default_randomizer_entries];
			}

			NumRandomSizeEntriesMinus1 = default_randomizer_entries - 1;

			float sscale = new_props.Rand * oo_intmax;
			for (unsigned int j = 0; j <= NumRandomSizeEntriesMinus1; j++) {
				RandomSizeEntries[j] = rand_gen * sscale;
			}
		}
	}
}


void ParticleBufferClass::Reset_Rotations(ParticlePropertyStruct<float> &new_props, float orient_rnd)
{

	unsigned int i;	// Used in loops	
   float oo_intmax = 1.0f / (float)INT_MAX;
	unsigned int ui_previous_key_time = 0;
	unsigned int ui_current_key_time = 0;

	/*
	** NOTE: Input rotations are in rotations per second. These will be converted to rotations per millisecond.
	*/

	RotationRandom = new_props.Rand * 0.001f;
	InitialOrientationRandom = orient_rnd;

	// If both randomizers are effectively zero and rotation is constant zero, then all arrays are NULL.
	static const float eps_orientation = 2.77777778e-4f;	// Epsilon is equivalent to 0.1 degree
	static const float eps_rotation = 2.77777778e-4f;	// Epsilon is equivalent to one rotation per hour (in rotations / second)
	bool orientation_rand_zero = fabs(orient_rnd) < eps_orientation;
	bool rotation_rand_zero = fabs(new_props.Rand) < eps_rotation;
	if (orientation_rand_zero && rotation_rand_zero && new_props.NumKeyFrames == 0 && fabs(new_props.Start) < eps_rotation) {

		// Release Arrays, 
		REF_PTR_RELEASE(Orientation);
		if (RotationKeyFrameTimes) {
			delete [] RotationKeyFrameTimes;
			RotationKeyFrameTimes = NULL;
		}
		if (HalfRotationKeyFrameDeltas) {
			delete [] HalfRotationKeyFrameDeltas;
			HalfRotationKeyFrameDeltas = NULL;
		}
		if (RotationKeyFrameValues) {
			delete [] RotationKeyFrameValues;
			RotationKeyFrameValues = NULL;
		}
		if (OrientationKeyFrameValues) {
			delete [] OrientationKeyFrameValues;
			OrientationKeyFrameValues = NULL;
		}

		NumRotationKeyFrames = 0;
		NumRandomRotationEntriesMinus1 = 0;
		NumRandomOrientationEntriesMinus1 = 0;
	
	} else {

		// Create the array if not present
		if (!Orientation) {
			Orientation = NEW_REF( ShareBufferClass<uint8> , (MaxNum) );
		}

		// Check times of the keyframes (each keytime must be larger than the
		// previous one by at least a millisecond, and we stop at the first
		// keytime of MaxAge or larger. (If all keyframes below MaxAge, the value is
		// constant during the last segment between last keyframe and MaxAge).
		ui_previous_key_time = 0;
		unsigned int key;
		for (key = 0; key < new_props.NumKeyFrames; key++) {
			ui_current_key_time = (unsigned int)(new_props.KeyTimes[key] * 1000.0f);
			WWASSERT(ui_current_key_time > ui_previous_key_time);
			if (ui_current_key_time >= MaxAge) break;
			ui_previous_key_time = ui_current_key_time;
		}
		bool rotation_constant_at_end = (key == new_props.NumKeyFrames);

		// Reuse RotationKeyFrameValues, RotationKeyFrameTimes, RotationKeyFrameDeltas and
		// OrientationKeyFrameValues if the right size, otherwise release and reallocate.
		unsigned int new_num_key_frames = key + 1;// Includes start keyframe (keytime == 0).
		if (new_num_key_frames != NumRotationKeyFrames) {

			if (RotationKeyFrameTimes) {
				delete [] RotationKeyFrameTimes;
				RotationKeyFrameTimes = NULL;
			}
			if (RotationKeyFrameValues) {
				delete [] RotationKeyFrameValues;
				RotationKeyFrameValues = NULL;
			}
			if (HalfRotationKeyFrameDeltas) {
				delete [] HalfRotationKeyFrameDeltas;
				HalfRotationKeyFrameDeltas = NULL;
			}
			if (OrientationKeyFrameValues) {
				delete [] OrientationKeyFrameValues;
				OrientationKeyFrameValues = NULL;
			}

			NumRotationKeyFrames = new_num_key_frames;
			RotationKeyFrameTimes = new unsigned int [NumRotationKeyFrames];
			RotationKeyFrameValues = new float [NumRotationKeyFrames];
			HalfRotationKeyFrameDeltas = new float [NumRotationKeyFrames];
			OrientationKeyFrameValues = new float [NumRotationKeyFrames];
		}

		// Set rotation keyframes (deltas will be set later)
		RotationKeyFrameTimes[0] = 0;
		RotationKeyFrameValues[0] = new_props.Start * 0.001f;
		for (i = 1; i < NumRotationKeyFrames; i++) {
			unsigned int im1 = i - 1;
			RotationKeyFrameTimes[i] = (unsigned int)(new_props.KeyTimes[im1] * 1000.0f);
			RotationKeyFrameValues[i] = new_props.Values[im1] * 0.001f;
		}

		// Do deltas for all rotation keyframes except last
		for (i = 0; i < NumRotationKeyFrames - 1; i++) {
			HalfRotationKeyFrameDeltas[i]	= 0.5f * ( (RotationKeyFrameValues[i + 1] - RotationKeyFrameValues[i]) /
				(float)(RotationKeyFrameTimes[i + 1] - RotationKeyFrameTimes[i]) );
		}

		// Do delta for last rotation keyframe (i is NumRotationKeyFrames - 1)
		if (rotation_constant_at_end) {
			HalfRotationKeyFrameDeltas[i] = 0.0f;
		} else {
			// This is OK because if rotation_constant_at_end is false, NumRotationKeyFrames is equal or
			// smaller than new_props.NumKeyFrames so new_props.Values[NumRotationKeyFrames - 1] and
			// new_props.KeyTimes[NumRotationKeyFrames - 1] exist.
			HalfRotationKeyFrameDeltas[i] = 0.5f * (new_props.Values[i] * 0.001f - RotationKeyFrameValues[i]) /
				(new_props.KeyTimes[i] * 1000.0f - (float)RotationKeyFrameTimes[i]);
		}

		// Calculate orientation keyframes by integrating the rotation at each keyframe
		OrientationKeyFrameValues[0] = 0.0f;
		for (i = 1; i < NumRotationKeyFrames; i++) {
			float delta_t = (float)(RotationKeyFrameTimes[i] - RotationKeyFrameTimes[i - 1]);
			OrientationKeyFrameValues[i] = OrientationKeyFrameValues[i - 1] + delta_t *
				(RotationKeyFrameValues[i - 1] + HalfRotationKeyFrameDeltas[i - 1] * delta_t);
		}

		// Set up rotation randomizer table
		if (rotation_rand_zero) {

			if (RandomRotationEntries) {
				// Reuse RandomRotationEntries if the right size, otherwise release and reallocate.
				if (NumRandomRotationEntriesMinus1 != 0) {
					delete [] RandomRotationEntries;
					RandomRotationEntries = new float [1];
				}
			} else {
				RandomRotationEntries = new float [1];
			}

			NumRandomRotationEntriesMinus1 = 0;
			RandomRotationEntries[0] = 0.0f;
		} else {

			// Default size of randomizer tables (tables for non-zero randomizers will be this size)
			unsigned int pot_num = Find_POT(MaxNum);
			unsigned int default_randomizer_entries = MIN(pot_num, MAX_RANDOM_ENTRIES);

			if (RandomRotationEntries) {
				// Reuse RandomRotationEntries if the right size, otherwise release and reallocate.
				if (NumRandomRotationEntriesMinus1 != (default_randomizer_entries - 1)) {
					delete [] RandomRotationEntries;
					RandomRotationEntries = new float [default_randomizer_entries];
				}
			} else {
				RandomRotationEntries = new float [default_randomizer_entries];
			}

			NumRandomRotationEntriesMinus1 = default_randomizer_entries - 1;

			float scale = new_props.Rand * 0.001f * oo_intmax;
			for (unsigned int j = 0; j <= NumRandomRotationEntriesMinus1; j++) {
				RandomRotationEntries[j] = rand_gen * scale;
			}
		}

		// Set up orientation randomizer table
		if (orientation_rand_zero) {

			if (RandomOrientationEntries) {
				// Reuse RandomOrientationEntries if the right size, otherwise release and reallocate.
				if (NumRandomOrientationEntriesMinus1 != 0) {
					delete [] RandomOrientationEntries;
					RandomOrientationEntries = new float [1];
				}
			} else {
				RandomOrientationEntries = new float [1];
			}

			NumRandomOrientationEntriesMinus1 = 0;
			RandomOrientationEntries[0] = 0.0f;
		} else {

			// Default size of randomizer tables (tables for non-zero randomizers will be this size)
			unsigned int pot_num = Find_POT(MaxNum);
			unsigned int default_randomizer_entries = MIN(pot_num, MAX_RANDOM_ENTRIES);

			if (RandomOrientationEntries) {
				// Reuse RandomOrientationEntries if the right size, otherwise release and reallocate.
				if (NumRandomOrientationEntriesMinus1 != (default_randomizer_entries - 1)) {
					delete [] RandomOrientationEntries;
					RandomOrientationEntries = new float [default_randomizer_entries];
				}
			} else {
				RandomOrientationEntries = new float [default_randomizer_entries];
			}

			NumRandomOrientationEntriesMinus1 = default_randomizer_entries - 1;

			float scale = orient_rnd * oo_intmax;
			for (unsigned int j = 0; j <= NumRandomOrientationEntriesMinus1; j++) {
				RandomOrientationEntries[j] = rand_gen * scale;
			}
		}
	}
}



void ParticleBufferClass::Reset_Frames(ParticlePropertyStruct<float> &new_props)
{

	unsigned int i;	// Used in loops	
   float oo_intmax = 1.0f / (float)INT_MAX;
	unsigned int ui_previous_key_time = 0;
	unsigned int ui_current_key_time = 0;

	FrameRandom = new_props.Rand;

	// If the randomizer is effectively zero and there are no keyframes, then we just create a
	// values array with one entry and store the starting value in it (the keyframes and random
	// table will not be used in this case).
	static const float eps_frame = 0.1f;	// Epsilon is equivalent to 0.1 frame
	bool frame_rand_zero	= (fabs(new_props.Rand) < eps_frame);
	if (frame_rand_zero && new_props.NumKeyFrames == 0) {

		// Release Arrays, Reuse KeyFrameValues if the right size, 
		// otherwise release and reallocate.
		REF_PTR_RELEASE(Frame);
		REF_PTR_RELEASE(UCoord);
		if (FrameKeyFrameTimes) {
			delete [] FrameKeyFrameTimes;
			FrameKeyFrameTimes = NULL;
		}
		if (FrameKeyFrameDeltas) {
			delete [] FrameKeyFrameDeltas;
			FrameKeyFrameDeltas = NULL;
		}
		if (FrameKeyFrameValues) {
			if (NumFrameKeyFrames > 1) {
				delete [] FrameKeyFrameValues;
				FrameKeyFrameValues = new float [1];
			}
		} else {
			FrameKeyFrameValues = new float [1];
		}

		NumFrameKeyFrames = 0;
		NumRandomFrameEntriesMinus1 = 0;
		FrameKeyFrameValues[0] = new_props.Start;
	
	} else {

		// Create the array if not present
		if ((RenderMode==W3D_EMITTER_RENDER_MODE_LINEGRP_TETRA) ||
			(RenderMode==W3D_EMITTER_RENDER_MODE_LINEGRP_PRISM)) {
			if (!UCoord) {
				UCoord = NEW_REF( ShareBufferClass<float>, (MaxNum) );
			}
		} else {
			if (!Frame) {
				Frame = NEW_REF( ShareBufferClass<uint8> , (MaxNum) );
			}
		}

		// Check times of the keyframes (each keytime must be larger than the
		// previous one by at least a millisecond, and we stop at the first
		// keytime of MaxAge or larger. (If all keyframes below MaxAge, the value is
		// constant during the last segment between last keyframe and MaxAge).
		ui_previous_key_time = 0;
		unsigned int key;
		for (key = 0; key < new_props.NumKeyFrames; key++) {
			ui_current_key_time = (unsigned int)(new_props.KeyTimes[key] * 1000.0f);
			WWASSERT(ui_current_key_time > ui_previous_key_time);
			if (ui_current_key_time >= MaxAge) break;
			ui_previous_key_time = ui_current_key_time;
		}
		bool frame_constant_at_end = (key == new_props.NumKeyFrames);

		// Reuse FrameKeyFrameValues, FrameKeyFrameTimes and FrameKeyFrameDeltas if the right size,
		// otherwise release and reallocate.
		unsigned int new_num_key_frames = key + 1;// Includes start keyframe (keytime == 0).
		if (new_num_key_frames != NumFrameKeyFrames) {

			if (FrameKeyFrameTimes) {
				delete [] FrameKeyFrameTimes;
				FrameKeyFrameTimes = NULL;
			}
			if (FrameKeyFrameValues) {
				delete [] FrameKeyFrameValues;
				FrameKeyFrameValues = NULL;
			}
			if (FrameKeyFrameDeltas) {
				delete [] FrameKeyFrameDeltas;
				FrameKeyFrameDeltas = NULL;
			}

			NumFrameKeyFrames = new_num_key_frames;	
			FrameKeyFrameTimes = new unsigned int [NumFrameKeyFrames];
			FrameKeyFrameValues = new float [NumFrameKeyFrames];
			FrameKeyFrameDeltas = new float [NumFrameKeyFrames];
		}

		// Set keyframes (deltas will be set later)
		FrameKeyFrameTimes[0] = 0;
		FrameKeyFrameValues[0] = new_props.Start;
		for (i = 1; i < NumFrameKeyFrames; i++) {
			unsigned int im1 = i - 1;
			FrameKeyFrameTimes[i] = (unsigned int)(new_props.KeyTimes[im1] * 1000.0f);
			FrameKeyFrameValues[i] = new_props.Values[im1];
		}

		// Do deltas for all frame keyframes except last
		for (i = 0; i < NumFrameKeyFrames - 1; i++) {
			FrameKeyFrameDeltas[i]	= (FrameKeyFrameValues[i + 1] - FrameKeyFrameValues[i]) /
				(float)(FrameKeyFrameTimes[i + 1] - FrameKeyFrameTimes[i]);
		}

		// Do delta for last frame keyframe (i is NumFrameKeyFrames - 1)
		if (frame_constant_at_end) {
			FrameKeyFrameDeltas[i] = 0.0f;
		} else {
			// This is OK because if frame_constant_at_end is false, NumFrameKeyFrames is equal or
			// smaller than new_props.NumKeyFrames so new_props.Values[NumFrameKeyFrames - 1] and
			// new_props.KeyTimes[NumFrameKeyFrames - 1] exist.
			FrameKeyFrameDeltas[i] = (new_props.Values[i] - FrameKeyFrameValues[i]) /
				(new_props.KeyTimes[i] * 1000.0f - (float)FrameKeyFrameTimes[i]);
		}

		// Set up frame randomizer table
		if (frame_rand_zero) {

			if (RandomFrameEntries) {
				// Reuse RandomFrameEntries if the right size, otherwise release and reallocate.
				if (NumRandomFrameEntriesMinus1 != 0) {
					delete [] RandomFrameEntries;
					RandomFrameEntries = new float [1];
				}
			} else {
				RandomFrameEntries = new float [1];
			}

			NumRandomFrameEntriesMinus1 = 0;
			RandomFrameEntries[0] = 0.0f;
		} else {

			// Default size of randomizer tables (tables for non-zero randomizers will be this size)
			unsigned int pot_num = Find_POT(MaxNum);
			unsigned int default_randomizer_entries = MIN(pot_num, MAX_RANDOM_ENTRIES);

			if (RandomFrameEntries) {
				// Reuse RandomFrameEntries if the right size, otherwise release and reallocate.
				if (NumRandomFrameEntriesMinus1 != (default_randomizer_entries - 1)) {
					delete [] RandomFrameEntries;
					RandomFrameEntries = new float [default_randomizer_entries];
				}
			} else {
				RandomFrameEntries = new float [default_randomizer_entries];
			}

			NumRandomFrameEntriesMinus1 = default_randomizer_entries - 1;

			float scale = new_props.Rand * oo_intmax;
			for (unsigned int j = 0; j <= NumRandomFrameEntriesMinus1; j++) {
				RandomFrameEntries[j] = rand_gen * scale;
			}
		}
	}
}


void ParticleBufferClass::Reset_Blur_Times(ParticlePropertyStruct<float> &new_blur_times)
{

	unsigned int i;	// Used in loops	
   float oo_intmax = 1.0f / (float)INT_MAX;
	unsigned int ui_previous_key_time = 0;
	unsigned int ui_current_key_time = 0;

	BlurTimeRandom = new_blur_times.Rand;

	// If the randomizer is effectively zero and there are no keyframes, then we just create a
	// values array with one entry and store the starting value in it (the keyframes and random
	// table will not be used in this case).
	static const float eps_blur = 1e-5f;	// Epsilon is equivalent to 1e-5 units per second
	bool blurtime_rand_zero	= (fabs(new_blur_times.Rand) < eps_blur);
	if (blurtime_rand_zero && new_blur_times.NumKeyFrames == 0) {

		// Release Arrays, Reuse KeyFrameValues if the right size, 
		// otherwise release and reallocate.		
		if (BlurTimeKeyFrameTimes) {
			delete [] BlurTimeKeyFrameTimes;
			BlurTimeKeyFrameTimes = NULL;
		}
		if (BlurTimeKeyFrameDeltas) {
			delete [] BlurTimeKeyFrameDeltas;
			BlurTimeKeyFrameDeltas = NULL;
		}
		if (BlurTimeKeyFrameValues) {
			if (NumBlurTimeKeyFrames > 1) {
				delete [] BlurTimeKeyFrameValues;
				BlurTimeKeyFrameValues = new float [1];
			}
		} else {
			BlurTimeKeyFrameValues = new float [1];
		}

		NumBlurTimeKeyFrames = 0;
		NumRandomBlurTimeEntriesMinus1 = 0;
		BlurTimeKeyFrameValues[0] = new_blur_times.Start;
	
	} else {

		// Check times of the keyframes (each keytime must be larger than the
		// previous one by at least a millisecond, and we stop at the first
		// keytime of MaxAge or larger. (If all keyframes below MaxAge, the value is
		// constant during the last segment between last keyframe and MaxAge).
		ui_previous_key_time = 0;
		unsigned int key;
		for (key = 0; key < new_blur_times.NumKeyFrames; key++) {
			ui_current_key_time = (unsigned int)(new_blur_times.KeyTimes[key] * 1000.0f);
			WWASSERT(ui_current_key_time > ui_previous_key_time);
			if (ui_current_key_time >= MaxAge) break;
			ui_previous_key_time = ui_current_key_time;
		}
		bool blurtime_constant_at_end = (key == new_blur_times.NumKeyFrames);

		// Reuse BlurTimeKeyFrameValues, BlurTimeKeyFrameTimes and BlurTimeKeyFrameDeltas if the right size,
		// otherwise release and reallocate.
		unsigned int new_num_key_frames = key + 1;// Includes start keyframe (keytime == 0).
		if (new_num_key_frames != NumBlurTimeKeyFrames) {

			if (BlurTimeKeyFrameTimes) {
				delete [] BlurTimeKeyFrameTimes;
				BlurTimeKeyFrameTimes = NULL;
			}
			if (BlurTimeKeyFrameValues) {
				delete [] BlurTimeKeyFrameValues;
				BlurTimeKeyFrameValues = NULL;
			}
			if (BlurTimeKeyFrameDeltas) {
				delete [] BlurTimeKeyFrameDeltas;
				BlurTimeKeyFrameDeltas = NULL;
			}

			NumBlurTimeKeyFrames = new_num_key_frames;	
			BlurTimeKeyFrameTimes = new unsigned int [NumBlurTimeKeyFrames];
			BlurTimeKeyFrameValues = new float [NumBlurTimeKeyFrames];
			BlurTimeKeyFrameDeltas = new float [NumBlurTimeKeyFrames];
		}

		// Set keyframes (deltas will be set later)
		BlurTimeKeyFrameTimes[0] = 0;
		BlurTimeKeyFrameValues[0] = new_blur_times.Start;
		for (i = 1; i < NumBlurTimeKeyFrames; i++) {
			unsigned int im1 = i - 1;
			BlurTimeKeyFrameTimes[i] = (unsigned int)(new_blur_times.KeyTimes[im1] * 1000.0f);
			BlurTimeKeyFrameValues[i] = new_blur_times.Values[im1];
		}

		// Do deltas for all frame keyframes except last
		for (i = 0; i < NumBlurTimeKeyFrames - 1; i++) {
			BlurTimeKeyFrameDeltas[i]	= (BlurTimeKeyFrameValues[i + 1] - BlurTimeKeyFrameValues[i]) /
				(float)(BlurTimeKeyFrameTimes[i + 1] - BlurTimeKeyFrameTimes[i]);
		}

		// Do delta for last frame keyframe (i is NumBlurTimeKeyFrames - 1)
		if (blurtime_constant_at_end) {
			BlurTimeKeyFrameDeltas[i] = 0.0f;
		} else {
			// This is OK because if frame_constant_at_end is false, NumBlurTimeKeyFrames is equal or
			// smaller than new_props.NumKeyFrames so new_props.Values[NumBlurTimeKeyFrames - 1] and
			// new_props.KeyTimes[NumBlurTimeKeyFrames - 1] exist.
			BlurTimeKeyFrameDeltas[i] = (new_blur_times.Values[i] - BlurTimeKeyFrameValues[i]) /
				(new_blur_times.KeyTimes[i] * 1000.0f - (float)BlurTimeKeyFrameTimes[i]);
		}

		// Set up frame randomizer table
		if (blurtime_rand_zero) {

			if (RandomBlurTimeEntries) {
				// Reuse RandomBlurTimeEntries if the right size, otherwise release and reallocate.
				if (NumRandomBlurTimeEntriesMinus1 != 0) {
					delete [] RandomBlurTimeEntries;
					RandomBlurTimeEntries = new float [1];
				}
			} else {
				RandomBlurTimeEntries = new float [1];
			}

			NumRandomBlurTimeEntriesMinus1 = 0;
			RandomBlurTimeEntries[0] = 0.0f;
		} else {

			// Default size of randomizer tables (tables for non-zero randomizers will be this size)
			unsigned int pot_num = Find_POT(MaxNum);
			unsigned int default_randomizer_entries = MIN(pot_num, MAX_RANDOM_ENTRIES);

			if (RandomBlurTimeEntries) {
				// Reuse RandomBlurTimeEntries if the right size, otherwise release and reallocate.
				if (NumRandomBlurTimeEntriesMinus1 != (default_randomizer_entries - 1)) {
					delete [] RandomBlurTimeEntries;
					RandomBlurTimeEntries = new float [default_randomizer_entries];
				}
			} else {
				RandomBlurTimeEntries = new float [default_randomizer_entries];
			}

			NumRandomBlurTimeEntriesMinus1 = default_randomizer_entries - 1;

			float scale = new_blur_times.Rand * oo_intmax;
			for (unsigned int j = 0; j <= NumRandomBlurTimeEntriesMinus1; j++) {
				RandomBlurTimeEntries[j] = rand_gen * scale;
			}
		}
	}
}


// This informs the buffer that the emitter is dead, so it can release
// its pointer to it and be removed itself after all its particles dies
// out.
void ParticleBufferClass::Emitter_Is_Dead(void)
{
	IsEmitterDead = true;
	// We do not have a ref for the emitter (see DTor for detailed explanation)
	// Emitter->Release_Ref();
	Emitter = NULL;
}


// This set's the buffer's current emitter - this should usually be
// called only by the emitter's copy constructor after it clones a
// buffer.
void ParticleBufferClass::Set_Emitter(ParticleEmitterClass *emitter)
{
	if (Emitter) {
		// We do not have a ref for the emitter (see DTor for detailed explanation)
		// Emitter->Release_Ref();
		Emitter = NULL;
	}

	Emitter = emitter;

	if (Emitter) {
		// We do not add a ref for the emitter (see DTor for detailed explanation)
		// Emitter->Add_Ref();
	}
}

		
NewParticleStruct * ParticleBufferClass::Add_Uninitialized_New_Particle(void)
{
	// Note that this function does not initialize the new particle - it
	// returns its address to a different function which performs the actual
	// initialization.

	// Push new particle on new particle queue. If it overflows, just adjust
	// queue to remove oldest member (which is the one which was overwritten).
	NewParticleStruct *ptr = &(NewParticleQueue[NewParticleQueueEnd]);
   if (++NewParticleQueueEnd == MaxNum) NewParticleQueueEnd = 0;
	if (++NewParticleQueueCount == (signed)(MaxNum + 1)) {
		// Overflow - advance queue start:
		if (++NewParticleQueueStart == MaxNum) NewParticleQueueStart = 0;
		NewParticleQueueCount--;
	}

	return ptr;
}


void ParticleBufferClass::Update_Cached_Bounding_Volumes(void) const
{
	// This ugly cast is done because the alternative is to make everything
	// in the class mutable, which does not seem like a good solution
	// (Update_Bounding_Box can potentially update the particle state).
	((ParticleBufferClass *)this)->Update_Bounding_Box();

	// Update cached bounding box and sphere according to the bounding box:
	CachedBoundingSphere.Init(BoundingBox.Center, BoundingBox.Extent.Length());
	CachedBoundingBox = BoundingBox;
	Validate_Cached_Bounding_Volumes();
}


void ParticleBufferClass::Update_Kinematic_Particle_State(void)
{
	// Note: elapsed may be very large indeed the first time the object is
	// updated, but this doesn't matter, since it is actually only used in
	// Update_Non_New_Particles(), which is never called on the first update.
	unsigned int elapsed = WW3D::Get_Sync_Time() - LastUpdateTime;
	if (elapsed == 0U) return;

	// Get new particles from the input buffer and write them into the circular
	// particle buffer, possibly overwriting older particles. Update each
	// according to its age.
	Get_New_Particles();

	// Kill all remaining particles which will pass their max age this update.
	Kill_Old_Particles();

	// Update all living, non-new particles by a uniform time interval.
	if (NonNewNum > 0) Update_Non_New_Particles(elapsed);

	// Mark all new particles as non-new.
	End = NewEnd;
	NonNewNum += NewNum;
	NewNum = 0;

	LastUpdateTime = WW3D::Get_Sync_Time();

	BoundingBoxDirty = true;
}


void ParticleBufferClass::Update_Visual_Particle_State(void)
{
	// NOTE: The visual state (color/alpha/size) is "stateless" in that each time it is calculated
	// without referring to what it was before. This is important for when we optimize the particle
	// systems/pointgroups in the future to chunk triangles into reusable small buffers.

	// If all visual state is constant do nothing.
	// Linegroup modes have a visual state that always have to be updated though
	bool is_linegroup=( (RenderMode==W3D_EMITTER_RENDER_MODE_LINEGRP_TETRA) ||
							  (RenderMode==W3D_EMITTER_RENDER_MODE_LINEGRP_PRISM));
	if (!Color && !Alpha && !Size && !Orientation && !Frame && !UCoord && !is_linegroup) return;

	// In the general case, a range in a circular buffer can be composed of up
	// to two subranges. Find the Start - End subranges.
	unsigned int sub1_end;		// End of subrange 1.
	unsigned int sub2_start;	// Start of subrange 2.
	if ((Start < End) || ((Start == End) && NonNewNum ==0)) {
		sub1_end = End;
		sub2_start = End;
	} else {
		sub1_end = MaxNum;
		sub2_start = 0;
	}

	unsigned int current_time = WW3D::Get_Sync_Time();

	// The following back-to-back pair of "for" loops traverses the circular
	// buffer subranges in proper order.
	unsigned int ckey = NumColorKeyFrames - 1;
	unsigned int akey = NumAlphaKeyFrames - 1;
	unsigned int skey = NumSizeKeyFrames - 1;
	unsigned int rkey = NumRotationKeyFrames - 1;
	unsigned int fkey = NumFrameKeyFrames - 1;
	unsigned int bkey = NumBlurTimeKeyFrames -1;

	unsigned int part;
	Vector3 *color = Color ? Color->Get_Array(): NULL;
	float *alpha = Alpha ? Alpha->Get_Array(): NULL;
	float *size = Size ? Size->Get_Array(): NULL;
	uint8 *orientation = Orientation ? Orientation->Get_Array(): NULL;
	uint8 *frame = Frame ? Frame->Get_Array(): NULL;
	float *ucoord = UCoord ? UCoord->Get_Array() : NULL;
	Vector3 *tailposition = TailPosition ? TailPosition->Get_Array() : NULL;

	Vector3 *position=NULL;

	if (PingPongPosition) {
		int pingpong = WW3D::Get_Frame_Count() & 0x1;
		position = Position[pingpong]->Get_Array();		
	} else {
		position = Position[0]->Get_Array();
	}


	for (part = Start; part < sub1_end; part++) {

		unsigned int part_age = current_time - TimeStamp[part];

		// Ensure the current color keyframe is correct, and calculate color state
		if (color) {
			// We go from older to younger particles, so we go backwards from the last keyframe until
			// age >= keytime. This loop must terminate because the 0th keytime is 0.
			for (; part_age < ColorKeyFrameTimes[ckey]; ckey--);

			color[part] = ColorKeyFrameValues[ckey] +
							ColorKeyFrameDeltas[ckey] * (float)(part_age - ColorKeyFrameTimes[ckey]) +
							RandomColorEntries[part & NumRandomColorEntriesMinus1];
		}

		// Ensure the current alpha keyframe is correct, and calculate alpha state
		if (alpha) {
			// We go from older to younger particles, so we go backwards from the last keyframe until
			// age >= keytime. This loop must terminate because the 0th keytime is 0.
			for (; part_age < AlphaKeyFrameTimes[akey]; akey--);

			alpha[part] = AlphaKeyFrameValues[akey] +
				AlphaKeyFrameDeltas[akey] * (float)(part_age - AlphaKeyFrameTimes[akey]) +
				RandomAlphaEntries[part & NumRandomAlphaEntriesMinus1];
		}

		// Ensure the current size keyframe is correct, and calculate size state
		if (size) {
			// We go from older to younger particles, so we go backwards from the last keyframe until
			// age >= keytime. This loop must terminate because the 0th keytime is 0.
			for (; part_age < SizeKeyFrameTimes[skey]; skey--);

			size[part] = SizeKeyFrameValues[skey] +
				SizeKeyFrameDeltas[skey] * (float)(part_age - SizeKeyFrameTimes[skey]) +
				RandomSizeEntries[part & NumRandomSizeEntriesMinus1];

			// Size (unlike color and alpha) isn't clamped in the engine, so we need to clamp
			// negative values to zero here:
			size[part] = (size[part] >= 0.0f) ? size[part] : 0.0f;
		}

		// Ensure the current rotation keyframe is correct, and calculate orientation state
		if (orientation) {
			// We go from older to younger particles, so we go backwards from the last keyframe until
			// age >= keytime. This loop must terminate because the 0th keytime is 0.
			for (; part_age < RotationKeyFrameTimes[rkey]; rkey--);

			float f_delta_t = (float)(part_age - RotationKeyFrameTimes[rkey]);
			float tmp_orient = OrientationKeyFrameValues[rkey] +
				(RotationKeyFrameValues[rkey] + HalfRotationKeyFrameDeltas[rkey] * f_delta_t) * f_delta_t +
				RandomRotationEntries[part & NumRandomRotationEntriesMinus1] * (float)part_age +
				RandomOrientationEntries[part & NumRandomOrientationEntriesMinus1];
			
			orientation[part] = (uint)(((int)(tmp_orient * 256.0f)) & 0xFF);
		}

		// Ensure the current frame keyframe is correct, and calculate frame state
		if (frame) {
			// Frame and ucoord are mutually exclusive
			WWASSERT(ucoord==NULL);
			// We go from older to younger particles, so we go backwards from the last keyframe until
			// age >= keytime. This loop must terminate because the 0th keytime is 0.
			for (; part_age < FrameKeyFrameTimes[fkey]; fkey--);

			float tmp_frame = FrameKeyFrameValues[fkey] +
				FrameKeyFrameDeltas[fkey] * (float)(part_age - FrameKeyFrameTimes[fkey]) +
				RandomFrameEntries[part & NumRandomFrameEntriesMinus1];
			
			frame[part] = (uint)(((int)(tmp_frame)) & 0xFF);
		}

		// Ensure the current frame keyframe is correct, and calculate frame state
		// ucoord is the same as frame but in float
		if (ucoord) {
			// Frame and ucoord are mutually exclusive
			WWASSERT(frame==NULL);
			// We go from older to younger particles, so we go backwards from the last keyframe until
			// age >= keytime. This loop must terminate because the 0th keytime is 0.
			for (; part_age < FrameKeyFrameTimes[fkey]; fkey--);

			ucoord[part] = FrameKeyFrameValues[fkey] +
				FrameKeyFrameDeltas[fkey] * (float)(part_age - FrameKeyFrameTimes[fkey]) +
				RandomFrameEntries[part & NumRandomFrameEntriesMinus1];		
		}

		if (tailposition) {
			// We go from older to younger particles, so we go backwards from the last keyframe until
			// age >= keytime. This loop must terminate because the 0th keytime is 0.
			float blur_time = BlurTimeKeyFrameValues[0];
			if (BlurTimeKeyFrameTimes) {
				for (; part_age < BlurTimeKeyFrameTimes[bkey]; bkey--);
				blur_time = BlurTimeKeyFrameValues[bkey] +
					BlurTimeKeyFrameDeltas[bkey] * (float)(part_age - BlurTimeKeyFrameTimes[bkey]) +
					RandomBlurTimeEntries[part & NumRandomBlurTimeEntriesMinus1];
			}
			tailposition[part]=position[part]-Velocity[part]*blur_time*1000;
		}		
	}

	for (part = sub2_start; part < End; part++) {

		unsigned int part_age = current_time - TimeStamp[part];

		// Ensure the current color keyframe is correct, and calculate color state
		if (color) {
			// We go from older to younger particles, so we go backwards from the last keyframe until
			// age >= keytime. This loop must terminate because the 0th keytime is 0.
			for (; part_age < ColorKeyFrameTimes[ckey]; ckey--);

			color[part] = 
					ColorKeyFrameValues[ckey] +
					ColorKeyFrameDeltas[ckey] * (float)(part_age - ColorKeyFrameTimes[ckey]) +
					RandomColorEntries[part & NumRandomColorEntriesMinus1];
		}

		// Ensure the current alpha keyframe is correct, and calculate alpha state
		if (alpha) {
			// We go from older to younger particles, so we go backwards from the last keyframe until
			// age >= keytime. This loop must terminate because the 0th keytime is 0.
			for (; part_age < AlphaKeyFrameTimes[akey]; akey--);

			alpha[part] = AlphaKeyFrameValues[akey] +
				AlphaKeyFrameDeltas[akey] * (float)(part_age - AlphaKeyFrameTimes[akey]) +
				RandomAlphaEntries[part & NumRandomAlphaEntriesMinus1];
		}

		// Ensure the current size keyframe is correct, and calculate size state
		if (size) {
			// We go from older to younger particles, so we go backwards from the last keyframe until
			// age >= keytime. This loop must terminate because the 0th keytime is 0.
			for (; part_age < SizeKeyFrameTimes[skey]; skey--);

			size[part] = SizeKeyFrameValues[skey] +
				SizeKeyFrameDeltas[skey] * (float)(part_age - SizeKeyFrameTimes[skey]) +
				RandomSizeEntries[part & NumRandomSizeEntriesMinus1];

			// Size (unlike color) isn't clamped in the engine, so we need to
			// clamp negative values to zero here:
			size[part] = (size[part] >= 0.0f) ? size[part] : 0.0f;
		}

		// Ensure the current rotation keyframe is correct, and calculate orientation state
		if (orientation) {
			// We go from older to younger particles, so we go backwards from the last keyframe until
			// age >= keytime. This loop must terminate because the 0th keytime is 0.
			for (; part_age < RotationKeyFrameTimes[rkey]; rkey--);

			float f_delta_t = (float)(part_age - RotationKeyFrameTimes[rkey]);
			float tmp_orient = OrientationKeyFrameValues[rkey] +
				(RotationKeyFrameValues[rkey] + HalfRotationKeyFrameDeltas[rkey] * f_delta_t) * f_delta_t +
				RandomRotationEntries[part & NumRandomRotationEntriesMinus1] * (float)part_age +
				RandomOrientationEntries[part & NumRandomOrientationEntriesMinus1];
			
			orientation[part] = (uint)(((int)(tmp_orient * 256.0f)) & 0xFF);
		}

		// Ensure the current frame keyframe is correct, and calculate frame state
		if (frame) {
			// Frame and ucoord are mutually exclusive
			WWASSERT(ucoord==NULL);
			// We go from older to younger particles, so we go backwards from the last keyframe until
			// age >= keytime. This loop must terminate because the 0th keytime is 0.
			for (; part_age < FrameKeyFrameTimes[fkey]; fkey--);

			float tmp_frame = FrameKeyFrameValues[fkey] +
				FrameKeyFrameDeltas[fkey] * (float)(part_age - FrameKeyFrameTimes[fkey]) +
				RandomFrameEntries[part & NumRandomFrameEntriesMinus1];
			
			frame[part] = (uint)(((int)(tmp_frame)) & 0xFF);
		}

		// Ensure the current frame keyframe is correct, and calculate frame state
		// ucoord is the same as frame but in float
		if (ucoord) {
			// Frame and ucoord are mutually exclusive
			WWASSERT(frame==NULL);
			// We go from older to younger particles, so we go backwards from the last keyframe until
			// age >= keytime. This loop must terminate because the 0th keytime is 0.
			for (; part_age < FrameKeyFrameTimes[fkey]; fkey--);

			ucoord[part] = FrameKeyFrameValues[fkey] +
				FrameKeyFrameDeltas[fkey] * (float)(part_age - FrameKeyFrameTimes[fkey]) +
				RandomFrameEntries[part & NumRandomFrameEntriesMinus1];			
		}

		if (tailposition) {
			// We go from older to younger particles, so we go backwards from the last keyframe until
			// age >= keytime. This loop must terminate because the 0th keytime is 0.
			float blur_time = BlurTimeKeyFrameValues[0];
			if (BlurTimeKeyFrameTimes) {
				for (; part_age < BlurTimeKeyFrameTimes[bkey]; bkey--);
				blur_time = BlurTimeKeyFrameValues[bkey] +
					BlurTimeKeyFrameDeltas[bkey] * (float)(part_age - BlurTimeKeyFrameTimes[bkey]) +
					RandomBlurTimeEntries[part & NumRandomBlurTimeEntriesMinus1];
			}
			tailposition[part]=position[part]-Velocity[part]*blur_time*1000;
		}
	}
}


void ParticleBufferClass::Update_Bounding_Box(void)
{
	// Ensure all particle positions are updated. If bounding box still not
	// dirty, return.
	Update_Kinematic_Particle_State();
	if (!BoundingBoxDirty) return;

	// If there are no particles, generate a dummy bounding box:
	if (NonNewNum == 0U) {
		BoundingBox.Init(Vector3(0.0, 0.0, 0.0), Vector3(0.0, 0.0, 0.0));
		BoundingBoxDirty = false;
		return;
	}

	// Find min/max coord values for all points:
	int pingpong = 0;
	if (PingPongPosition) {
		pingpong = WW3D::Get_Frame_Count() & 0x1;
	}
	Vector3 *position = Position[pingpong]->Get_Array();
	Vector3 max_coords = position[Start];
	Vector3 min_coords = position[Start];

	// In the general case, a range in a circular buffer can be composed of up
	// to two subranges. Find the Start - End subranges.
	unsigned int sub1_end;		// End of subrange 1.
	unsigned int sub2_start;	// Start of subrange 2.
	unsigned int i;				// Loop index.
	if ((Start < End) || ((Start == End) && NonNewNum ==0)) {
		sub1_end = End;
		sub2_start = End;
	} else {
		sub1_end = MaxNum;
		sub2_start = 0;
	}
   for (i = Start; i < sub1_end; i++) {
		max_coords.X = max_coords.X >= position[i].X ? max_coords.X : position[i].X;
		max_coords.Y = max_coords.Y >= position[i].Y ? max_coords.Y : position[i].Y;
		max_coords.Z = max_coords.Z >= position[i].Z ? max_coords.Z : position[i].Z;
		min_coords.X = min_coords.X <= position[i].X ? min_coords.X : position[i].X;
		min_coords.Y = min_coords.Y <= position[i].Y ? min_coords.Y : position[i].Y;
		min_coords.Z = min_coords.Z <= position[i].Z ? min_coords.Z : position[i].Z;
	}
   for (i = sub2_start; i < End; i++) {
		max_coords.X = max_coords.X >= position[i].X ? max_coords.X : position[i].X;
		max_coords.Y = max_coords.Y >= position[i].Y ? max_coords.Y : position[i].Y;
		max_coords.Z = max_coords.Z >= position[i].Z ? max_coords.Z : position[i].Z;
		min_coords.X = min_coords.X <= position[i].X ? min_coords.X : position[i].X;
		min_coords.Y = min_coords.Y <= position[i].Y ? min_coords.Y : position[i].Y;
		min_coords.Z = min_coords.Z <= position[i].Z ? min_coords.Z : position[i].Z;
	}
	
	// Extend by maximum possible particle size:
	Vector3 size(MaxSize, MaxSize, MaxSize);
	max_coords += size;
	min_coords -= size;

	// Update bounding box:
	BoundingBox.Init(MinMaxAABoxClass(min_coords,max_coords));
	BoundingBoxDirty = false;
}


// NOTE: typically, the number of new particles created in a frame is small
// relative to the total number of particles, so this is not the most
// performance-critical particle function. New particles are copied from the
// new particle vector into the circular buffer, overwriting any older
// particles (including possibly other new particles) so that the newest
// particles are preserved. The particles are initialized to their state at
// the end of the current interval.
void ParticleBufferClass::Get_New_Particles(void)
{
	unsigned int current_time = WW3D::Get_Sync_Time();

	// position is the current frame position, prev_pos is the previous frames position (only if
	// we have enabled pingpong position buffers)
	Vector3 *position;
	Vector3 *prev_pos;
	if (PingPongPosition) {
		int pingpong = WW3D::Get_Frame_Count() & 0x1;
		position = Position[pingpong]->Get_Array();
		prev_pos = Position[pingpong ^ 0x1]->Get_Array();
	} else {
		position = Position[0]->Get_Array();
		prev_pos = NULL;
	}

	for (; NewParticleQueueCount;) {

		// Get particle off new particle queue:
		NewParticleStruct &new_particle = NewParticleQueue[NewParticleQueueStart];
		if (++NewParticleQueueStart == MaxNum) NewParticleQueueStart = 0U;
		NewParticleQueueCount--;

		// Get particle birth time stamp, calculate age. If not under maxage
		// skip this particle.
		TimeStamp[NewEnd] = new_particle.TimeStamp;
		unsigned int age = current_time - TimeStamp[NewEnd];
		if (age >= MaxAge) continue;
		float fp_age = (float)age;

		// Apply velocity and acceleration if present. Otherwise, just apply
		// velocity.
		if (HasAccel) {
			position[NewEnd] = new_particle.Position +
									(new_particle.Velocity + 0.5f * Accel * fp_age) * fp_age;
			
			Velocity[NewEnd] = new_particle.Velocity + (Accel * fp_age);
		} else {
			position[NewEnd] =new_particle.Position +
										(new_particle.Velocity * fp_age);
			Velocity[NewEnd] = new_particle.Velocity;
		}

		// If pingpong enabled, store starting position in prev_pos[].
		if (PingPongPosition) {
			prev_pos[NewEnd] = new_particle.Position;
		}

		// Advance the 'end of new particles' index.
		NewEnd++;
      if (NewEnd == MaxNum) NewEnd = 0;

      // Update the new particles count.
      NewNum++;

		// If we have just overflowed the total buffer, advance Start.
      if ((NewNum + NonNewNum) == (signed)(MaxNum + 1)) {
         Start++;
         if (Start == MaxNum) Start = 0;
         NonNewNum--;

         // If this underflows the 'non-new' buffer, advance End.
         if (NonNewNum == -1) {
            End++;
            if (End == MaxNum) End = 0;
            NonNewNum = 0;
            NewNum--;
         }
      }
	}
}


void ParticleBufferClass::Kill_Old_Particles(void)
{
	// Scan from Start and find the first particle which has an age less than
	// MaxAge - set Start to that position.

	// In the general case, a range in a circular buffer can be composed of up
	// to two subranges. Find the Start - End subranges.
	unsigned int sub1_end;		// End of subrange 1.
	unsigned int sub2_start;	// Start of subrange 2.
	unsigned int i;				// Loop index.
	if ((Start < End) || ((Start == End) && NonNewNum ==0)) {
		sub1_end = End;
		sub2_start = End;
	} else {
		sub1_end = MaxNum;
		sub2_start = 0;
	}

   unsigned int current_time = WW3D::Get_Sync_Time();

	// Stop when the current particle is young enough to be alive.
	bool broke = false;
   for (i = Start; i < sub1_end; i++) {
      if ((current_time - TimeStamp[i]) < MaxAge) {
         broke = true;
         break;
      }
      NonNewNum--;
	}
   if (!broke) {
	   for (i = sub2_start; i < End; i++) {
		   if ((current_time - TimeStamp[i]) < MaxAge) break;
         NonNewNum--;
	   }
   }

	Start = i;

   // NOTE: we do not scan the new particles, because they have been already
   // preculled to be under MaxAge.
}


void ParticleBufferClass::Update_Non_New_Particles(unsigned int elapsed)
{
	// In the general case, a range in a circular buffer can be composed of up
	// to two subranges. Find the Start - End subranges.
	unsigned int sub1_end;		// End of subrange 1.
	unsigned int sub2_start;	// Start of subrange 2.
	unsigned int i;				// Loop index.
	if ((Start < End) || ((Start == End) && NonNewNum ==0)) {
		sub1_end = End;
		sub2_start = End;
	} else {
		sub1_end = MaxNum;
		sub2_start = 0;
	}

	float fp_elapsed_time = (float)elapsed;

	// Update position and velocity for all particles.
	if (PingPongPosition) {

		int pingpong = WW3D::Get_Frame_Count() & 0x1;
		Vector3 *position = Position[pingpong]->Get_Array();
		Vector3 *prev_pos = Position[pingpong ^ 0x1]->Get_Array();

		if (HasAccel) {
			Vector3 delta_v = Accel * fp_elapsed_time;
			Vector3 accel_p = Accel * (0.5f * fp_elapsed_time * fp_elapsed_time);
			for (i = Start; i < sub1_end; i++) {
				position[i] = prev_pos[i] + Velocity[i] * fp_elapsed_time + accel_p;
				Velocity[i] += delta_v;
			}
			for (i = sub2_start; i < End; i++) {
				position[i] = prev_pos[i] + Velocity[i] * fp_elapsed_time + accel_p;
				Velocity[i] += delta_v;
			}
		} else {
			for (i = Start; i < sub1_end; i++) {
				position[i] += Velocity[i] * fp_elapsed_time;
			}
			for (i = sub2_start; i < End; i++) {
				position[i] += Velocity[i] * fp_elapsed_time;
			}
		}
	} else {

		Vector3 *position = Position[0]->Get_Array();

		if (HasAccel) {
			Vector3 delta_v = Accel * fp_elapsed_time;
			Vector3 accel_p = Accel * (0.5f * fp_elapsed_time * fp_elapsed_time);
			for (i = Start; i < sub1_end; i++) {
				position[i] += Velocity[i] * fp_elapsed_time + accel_p;
				Velocity[i] += delta_v;
			}
			for (i = sub2_start; i < End; i++) {
				position[i] += Velocity[i] * fp_elapsed_time + accel_p;
				Velocity[i] += delta_v;
			}
		} else {
			for (i = Start; i < sub1_end; i++) {
				position[i] += Velocity[i] * fp_elapsed_time;
			}
			for (i = sub2_start; i < End; i++) {
				position[i] += Velocity[i] * fp_elapsed_time;
			}
		}
	}
}

void ParticleBufferClass::Get_Color_Key_Frames (ParticlePropertyStruct<Vector3> &colors) const
{
	int real_keyframe_count = (NumColorKeyFrames > 0) ? (NumColorKeyFrames - 1) : 0;
	bool create_last_keyframe = false;

	//
	//	Determine if there is a keyframe at the very end of the particle's lifetime
	//
	if ((ColorKeyFrameDeltas != NULL) &&
		 ((ColorKeyFrameDeltas[NumColorKeyFrames - 1].X != 0) ||
		  (ColorKeyFrameDeltas[NumColorKeyFrames - 1].Y != 0) ||
		  (ColorKeyFrameDeltas[NumColorKeyFrames - 1].Z != 0))) {
		real_keyframe_count ++;
		create_last_keyframe = true;
	}

	colors.Start = ColorKeyFrameValues[0];
	colors.Rand = ColorRandom;
	colors.NumKeyFrames = real_keyframe_count;
	colors.KeyTimes = NULL;
	colors.Values = NULL;

	//
	//	If we have more than just the start color, build
	// an array of key times and color vatues
	//
	if (real_keyframe_count > 0) {
		colors.KeyTimes	= new float[real_keyframe_count];
		colors.Values		= new Vector3[real_keyframe_count];

		//
		//	Copy the keytimes and color values
		//
		unsigned int index;
		for (index = 1; index < NumColorKeyFrames; index ++) {
			colors.KeyTimes[index - 1]	= ((float)ColorKeyFrameTimes[index]) / 1000;
			colors.Values[index - 1]	= ColorKeyFrameValues[index];
		}

		//
		//	Add a keyframe at the very end of the timeline if necessary
		//
		if (create_last_keyframe) {			
			colors.KeyTimes[index - 1] = ((float)MaxAge / 1000);

			//
			// Determine what the value of the last keyframe should be
			//
			Vector3 start_color = ColorKeyFrameValues[index - 1];
			Vector3 &delta = ColorKeyFrameDeltas[NumColorKeyFrames - 1];
			float time_delta = MaxAge - ColorKeyFrameTimes[index - 1];
			colors.Values[index - 1] = start_color + (delta * time_delta);
		}
	}

	return ;
}

void ParticleBufferClass::Get_Opacity_Key_Frames (ParticlePropertyStruct<float> &opacities) const
{
	int real_keyframe_count = (NumAlphaKeyFrames > 0) ? (NumAlphaKeyFrames - 1) : 0;
	bool create_last_keyframe = false;

	//
	//	Determine if there is a keyframe at the very end of the particle's lifetime
	//
	if ((AlphaKeyFrameDeltas != NULL) &&
		 (AlphaKeyFrameDeltas[NumAlphaKeyFrames - 1] != 0)) {
		real_keyframe_count ++;
		create_last_keyframe = true;
	}

	opacities.Start = AlphaKeyFrameValues[0];
	opacities.Rand = OpacityRandom;
	opacities.NumKeyFrames = real_keyframe_count;
	opacities.KeyTimes = NULL;
	opacities.Values = NULL;

	//
	//	If we have more than just the start opacity, build
	// an array of key times and opacity values
	//
	if (real_keyframe_count > 0) {
		opacities.KeyTimes	= new float[real_keyframe_count];
		opacities.Values		= new float[real_keyframe_count];

		//
		//	Copy the keytimes and opacity values
		//
		unsigned int index;
		for (index = 1; index < NumAlphaKeyFrames; index ++) {
			opacities.KeyTimes[index - 1]	= ((float)AlphaKeyFrameTimes[index]) / 1000;
			opacities.Values[index - 1]	= AlphaKeyFrameValues[index];
		}

		//
		//	Add a keyframe at the very end of the timeline if necessary
		//
		if (create_last_keyframe) {			
			opacities.KeyTimes[index - 1] = ((float)MaxAge / 1000);

			//
			// Determine what the value of the last keyframe should be
			//
			float start_alpha = AlphaKeyFrameValues[index - 1];
			float &delta = AlphaKeyFrameDeltas[NumAlphaKeyFrames - 1];
			float time_delta = MaxAge - AlphaKeyFrameTimes[index - 1];
			opacities.Values[index - 1] = start_alpha + (delta * time_delta);
		}
	}

	return ;
}


void ParticleBufferClass::Get_Size_Key_Frames (ParticlePropertyStruct<float> &sizes) const
{
	int real_keyframe_count = (NumSizeKeyFrames > 0) ? (NumSizeKeyFrames - 1) : 0;
	bool create_last_keyframe = false;

	//
	//	Determine if there is a keyframe at the very end of the particle's lifetime
	//
	if ((SizeKeyFrameDeltas != NULL) &&
		 (SizeKeyFrameDeltas[NumSizeKeyFrames - 1] != 0)) {
		real_keyframe_count ++;
		create_last_keyframe = true;
	}

	sizes.Start				= SizeKeyFrameValues[0];
	sizes.Rand				= SizeRandom;
	sizes.NumKeyFrames	= real_keyframe_count;
	sizes.KeyTimes			= NULL;
	sizes.Values			= NULL;

	//
	//	If we have more than just the start opacity, build
	// an array of key times and opacity values
	//
	if (real_keyframe_count > 0) {
		sizes.KeyTimes	= new float[real_keyframe_count];
		sizes.Values	= new float[real_keyframe_count];

		//
		//	Copy the keytimes and size values
		//
		unsigned int index;
		for (index = 1; index < NumSizeKeyFrames; index ++) {
			sizes.KeyTimes[index - 1]	= ((float)SizeKeyFrameTimes[index]) / 1000;
			sizes.Values[index - 1]	= SizeKeyFrameValues[index];
		}

		//
		//	Add a keyframe at the very end of the timeline if necessary
		//
		if (create_last_keyframe) {			
			sizes.KeyTimes[index - 1] = ((float)MaxAge / 1000);

			//
			// Determine what the value of the last keyframe should be
			//
			float start_size			= SizeKeyFrameValues[index - 1];
			float &delta				= SizeKeyFrameDeltas[NumSizeKeyFrames - 1];
			float time_delta			= MaxAge - SizeKeyFrameTimes[index - 1];
			sizes.Values[index - 1]	= start_size + (delta * time_delta);
		}
	}

	return ;
}


void ParticleBufferClass::Get_Rotation_Key_Frames (ParticlePropertyStruct<float> &rotations) const
{
	int real_keyframe_count = (NumRotationKeyFrames > 0) ? (NumRotationKeyFrames - 1) : 0;
	bool create_last_keyframe = false;

	/*
	** NOTE: Rotations are stored internally in rotations per millisecond. These will be converted to rotations per second.
	*/

	//
	//	Determine if there is a keyframe at the very end of the particle's lifetime
	//
	if ((HalfRotationKeyFrameDeltas != NULL) &&
		 (HalfRotationKeyFrameDeltas[NumRotationKeyFrames - 1] != 0)) {
		real_keyframe_count ++;
		create_last_keyframe = true;
	}

	// Convert the rotation values from rotations per millisecond to rotations per second.
	rotations.Start			= RotationKeyFrameValues ? RotationKeyFrameValues[0] * 1000.0f : 0;
	rotations.Rand				= RotationRandom * 1000.0f;
	rotations.NumKeyFrames	= real_keyframe_count;
	rotations.KeyTimes		= NULL;
	rotations.Values			= NULL;

	//
	//	If we have more than just the start rotation, build
	// an array of key times and rotation values
	//
	if (real_keyframe_count > 0) {
		rotations.KeyTimes	= new float[real_keyframe_count];
		rotations.Values		= new float[real_keyframe_count];

		//
		//	Copy the keytimes and rotation values
		//
		unsigned int index;
		for (index = 1; index < NumRotationKeyFrames; index ++) {
			rotations.KeyTimes[index - 1]	= ((float)RotationKeyFrameTimes[index]) / 1000;
			rotations.Values[index - 1]	= RotationKeyFrameValues[index] * 1000.0f;
		}

		//
		//	Add a keyframe at the very end of the timeline if necessary
		//
		if (create_last_keyframe) {			
			rotations.KeyTimes[index - 1] = ((float)MaxAge / 1000);

			//
			// Determine what the value of the last keyframe should be
			//
			float start_rotation				= RotationKeyFrameValues[index - 1];
			float delta							= 2.0f * HalfRotationKeyFrameDeltas[NumRotationKeyFrames - 1];
			float time_delta					= MaxAge - RotationKeyFrameTimes[index - 1];
			rotations.Values[index - 1]	= (start_rotation + (delta * time_delta)) * 1000.0f;
		}
	}

	return ;
}


void ParticleBufferClass::Get_Frame_Key_Frames (ParticlePropertyStruct<float> &frames) const
{
	int real_keyframe_count = (NumFrameKeyFrames > 0) ? (NumFrameKeyFrames - 1) : 0;
	bool create_last_keyframe = false;

	//
	//	Determine if there is a keyframe at the very end of the particle's lifetime
	//
	if ((FrameKeyFrameDeltas != NULL) &&
		 (FrameKeyFrameDeltas[NumFrameKeyFrames - 1] != 0)) {
		real_keyframe_count ++;
		create_last_keyframe = true;
	}

	frames.Start			= FrameKeyFrameValues[0];
	frames.Rand				= FrameRandom;
	frames.NumKeyFrames	= real_keyframe_count;
	frames.KeyTimes		= NULL;
	frames.Values			= NULL;

	//
	//	If we have more than just the start rotation, build
	// an array of key times and frame values
	//
	if (real_keyframe_count > 0) {
		frames.KeyTimes	= new float[real_keyframe_count];
		frames.Values		= new float[real_keyframe_count];

		//
		//	Copy the keytimes and frame values
		//
		unsigned int index;
		for (index = 1; index < NumFrameKeyFrames; index ++) {
			frames.KeyTimes[index - 1]	= ((float)FrameKeyFrameTimes[index]) / 1000;
			frames.Values[index - 1]	= FrameKeyFrameValues[index];
		}

		//
		//	Add a keyframe at the very end of the timeline if necessary
		//
		if (create_last_keyframe) {			
			frames.KeyTimes[index - 1] = ((float)MaxAge / 1000);

			//
			// Determine what the value of the last keyframe should be
			//
			float start_frame			= FrameKeyFrameValues[index - 1];
			float &delta				= FrameKeyFrameDeltas[NumFrameKeyFrames - 1];
			float time_delta			= MaxAge - FrameKeyFrameTimes[index - 1];
			frames.Values[index - 1]	= start_frame + (delta * time_delta);
		}
	}

	return ;
}

void ParticleBufferClass::Get_Blur_Time_Key_Frames (ParticlePropertyStruct<float> &blurtimes) const
{
	int real_keyframe_count = (NumBlurTimeKeyFrames > 0) ? (NumBlurTimeKeyFrames - 1) : 0;
	bool create_last_keyframe = false;

	//
	//	Determine if there is a keyframe at the very end of the particle's lifetime
	//
	if ((BlurTimeKeyFrameDeltas != NULL) &&
		 (BlurTimeKeyFrameDeltas[NumBlurTimeKeyFrames - 1] != 0)) {
		real_keyframe_count ++;
		create_last_keyframe = true;
	}

	blurtimes.Start			= BlurTimeKeyFrameValues[0];
	blurtimes.Rand				= BlurTimeRandom;
	blurtimes.NumKeyFrames	= real_keyframe_count;
	blurtimes.KeyTimes		= NULL;
	blurtimes.Values			= NULL;

	//
	//	If we have more than just the start rotation, build
	// an array of key times and blur time values
	//
	if (real_keyframe_count > 0) {
		blurtimes.KeyTimes	= new float[real_keyframe_count];
		blurtimes.Values		= new float[real_keyframe_count];

		//
		//	Copy the keytimes and frame values
		//
		unsigned int index;
		for (index = 1; index < NumBlurTimeKeyFrames; index ++) {
			blurtimes.KeyTimes[index - 1]	= ((float)BlurTimeKeyFrameTimes[index]) / 1000;
			blurtimes.Values[index - 1]	= BlurTimeKeyFrameValues[index];
		}

		//
		//	Add a keyframe at the very end of the timeline if necessary
		//
		if (create_last_keyframe) {			
			blurtimes.KeyTimes[index - 1] = ((float)MaxAge / 1000);

			//
			// Determine what the value of the last keyframe should be
			//
			float start_blurtime		= BlurTimeKeyFrameValues[index - 1];
			float &delta				= BlurTimeKeyFrameDeltas[NumBlurTimeKeyFrames - 1];
			float time_delta			= MaxAge - BlurTimeKeyFrameTimes[index - 1];
			blurtimes.Values[index - 1]	= start_blurtime + (delta * time_delta);
		}
	}

	return ;
}

void ParticleBufferClass::Set_LOD_Max_Screen_Size(int lod_level,float max_screen_size)
{
	if ((lod_level <0) || (lod_level > 17)) {
		return;
	}
	LODMaxScreenSizes[lod_level] = max_screen_size;
}


float ParticleBufferClass::Get_LOD_Max_Screen_Size(int lod_level)
{
	if ((lod_level <0) || (lod_level > 17)) {
		return NO_MAX_SCREEN_SIZE;
	}
	return LODMaxScreenSizes[lod_level];
}


int ParticleBufferClass::Get_Line_Texture_Mapping_Mode(void) const
{
	if (LineRenderer != NULL) {
		return LineRenderer->Get_Texture_Mapping_Mode();
	} 
	return SegLineRendererClass::UNIFORM_WIDTH_TEXTURE_MAP;
}

int ParticleBufferClass::Is_Merge_Intersections(void) const
{
	if (LineRenderer != NULL) {
		return LineRenderer->Is_Merge_Intersections();
	} 
	return false;
}

int ParticleBufferClass::Is_Freeze_Random(void) const
{
	if (LineRenderer != NULL) {
		return LineRenderer->Is_Freeze_Random();
	} 
	return false;
}

int ParticleBufferClass::Is_Sorting_Disabled(void) const
{
	if (LineRenderer != NULL) {
		return LineRenderer->Is_Sorting_Disabled();
	} 
	return false;
}

int ParticleBufferClass::Are_End_Caps_Enabled(void)	const
{
	if (LineRenderer != NULL) {
		return LineRenderer->Are_End_Caps_Enabled();
	} 
	return false;
}

int ParticleBufferClass::Get_Subdivision_Level(void) const
{
	if (LineRenderer != NULL) {
		return LineRenderer->Get_Current_Subdivision_Level();
	} 
	return 0;
}

float ParticleBufferClass::Get_Noise_Amplitude(void) const
{
	if (LineRenderer != NULL) {
		return LineRenderer->Get_Noise_Amplitude();
	} 
	return 0.0f;
}

float ParticleBufferClass::Get_Merge_Abort_Factor(void) const
{
	if (LineRenderer != NULL) {
		return LineRenderer->Get_Merge_Abort_Factor();
	} 
	return 0.0f;
}

float ParticleBufferClass::Get_Texture_Tile_Factor(void) const
{
	if (LineRenderer != NULL) {
		return LineRenderer->Get_Texture_Tile_Factor();
	} 
	return 1.0f;
}

Vector2 ParticleBufferClass::Get_UV_Offset_Rate(void) const
{
	if (LineRenderer != NULL) {
		return LineRenderer->Get_UV_Offset_Rate();
	} 
	return Vector2(0.0f,0.0f);
}

ParticleBufferClass::TailDiffuseTypeEnum ParticleBufferClass::Determine_Tail_Diffuse()
{
	// if there is a texture, the assumption is that the artist
	// is controlling the fadeoff ramp using the texture
	// thus, the ARGB of the tail should be the same as the head
	TextureClass *tex=Get_Texture();
	if (tex)
	{
		REF_PTR_RELEASE(tex);
		return SAME_AS_HEAD;
	}

	ShaderClass shader=Get_Shader();

	
	//Multiplicative		RGB is white (A is don't care)
	//Additive				RGB is Black (A is don't care)
	//Screen					RGB is Black (A is don't care)
	//Alpha					Same RGB as head but A is 0
	//Alpha test blend	Same ARGB as head but A is 0	
	//Alpha test			Same ARGB as head
	//Opaque					Same ARGB as head	

	// Multiplicative
	if (shader.Get_Dst_Blend_Func()==ShaderClass::DSTBLEND_SRC_COLOR) return WHITE;
	// Additive
	else if ((shader.Get_Src_Blend_Func()==ShaderClass::SRCBLEND_ONE) && (shader.Get_Dst_Blend_Func()==ShaderClass::DSTBLEND_ONE)) return BLACK;
	// Screen
	else if ((shader.Get_Src_Blend_Func()==ShaderClass::SRCBLEND_ONE) && (shader.Get_Dst_Blend_Func()==ShaderClass::DSTBLEND_ONE_MINUS_SRC_COLOR)) return BLACK;
	// Alpha
	else if ((shader.Get_Src_Blend_Func()==ShaderClass::SRCBLEND_SRC_ALPHA) && (shader.Get_Dst_Blend_Func()==ShaderClass::DSTBLEND_ONE_MINUS_SRC_ALPHA)) return SAME_AS_HEAD_ALPHA_ZERO;
	// Alpha test
	else if (shader.Get_Alpha_Test()==ShaderClass::ALPHATEST_ENABLE) return SAME_AS_HEAD_ALPHA_ZERO;

	return SAME_AS_HEAD;
}

TextureClass * ParticleBufferClass::Get_Texture (void) const
{
	if (PointGroup) return PointGroup->Get_Texture();
	else if (LineGroup) return LineGroup->Get_Texture();
	else if (LineRenderer) return LineRenderer->Get_Texture();
	return NULL;
}

void ParticleBufferClass::Set_Texture (TextureClass *tex)
{
	if (PointGroup) PointGroup->Set_Texture(tex);
	else if (LineGroup) LineGroup->Set_Texture(tex);
	else if (LineRenderer) LineRenderer->Set_Texture(tex);
}

ShaderClass ParticleBufferClass::Get_Shader (void) const
{
	if (PointGroup) return PointGroup->Get_Shader();
	else if (LineGroup) return LineGroup->Get_Shader();
	else if (LineRenderer) return LineRenderer->Get_Shader();

	WWASSERT(0);
	return ShaderClass::_PresetOpaqueShader;
}